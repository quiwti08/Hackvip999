local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false -- Forces AddToggle to AddCheckbox
Library.ShowToggleFrameInKeybinds = true -- Make toggle keybinds work inside the keybinds UI (aka adds a toggle to the UI). Good for mobile users (Default value = true)

local Window = Library:CreateWindow({
	Title = "nigga.lol",
	Footer = "nigga.lol | vhuy-anhchangm52",
	Icon = 5013109572,
	NotifySide = "Right",
	ShowCustomCursor = true,
	Resizable = true, -- Make the window resizable as per example
})

local Tabs = {
	Main = Window:AddTab("Aimbot", "user"),
	["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

-- Original script globals and functions remain unchanged
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local AIM_RADIUS = 300
local AIM_FOV = 100
local AIM_SMOOTHNESS = 0.9
local TriggerBotEnabled = true
local fovRadius = 15
local movementEnabled = false
local jumpPower = 50
local walkSpeed = 16
local teamCheck = false
local HitboxEnabled = false
local HitboxTransparency = 0.9
local HitboxSize = 15
local korbloxEnabled = true
local addedAccessories = {}
local runServiceConn
local Time = 1
local killAuraEnabled = false
local killSelectedEnabled = false
local spectateEnabled = false
local spectateTarget = nil
local originalPosition = nil
local originalCameraType = Camera.CameraType
local originalCameraSubject = Camera.CameraSubject
local originalCameraCFrame = Camera.CFrame
local cameraYaw = math.rad(0)
local cameraPitch = math.rad(0)
local camDistance = 5
local minCamDistance = 2
local maxCamDistance = 15
local zoomSensitivity = 2
local RightUpperLegAccessories = {
    {id = 18457575895}, 
}

-- Initialize Notifications tables
local Notifications = {}
local TargetNotifications = {}

-- Global settings
getgenv().YeuTuyen = {
    Status = true,
    Hitpart = "Head",
    SelectedTargets = {},
    ESPEnabled = false,
    Mode = "Aimbot",
    CheckIfJumped = true,
    CheckIfJumpedAimPart = "HumanoidRootPart",
    AutoPingSets = true,
    UseShake = true,
    ShakePower = 1,
    PredictMovement = false,
    PredictionVelocity = 0.17221418,
    UnderGround = false,
    DetectDesync = true,
    Detection = 75,
}

-- FOV Circle
local fovCircle = Drawing.new("Circle")
fovCircle.Visible = true
fovCircle.Radius = AIM_FOV
fovCircle.Thickness = 2
fovCircle.NumSides = 100
fovCircle.Color = Color3.fromRGB(255, 255, 255)
fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

-- Cycle FOV circle color
local colorValue = 255
local increasing = false
task.spawn(function()
    while true do
        task.wait(0)
        if increasing then
            colorValue = colorValue + 1
            if colorValue >= 255 then
                increasing = false
            end
        else
            colorValue = colorValue - 1
            if colorValue <= 0 then
                increasing = true
            end
        end
        fovCircle.Color = Color3.fromRGB(colorValue, colorValue, colorValue)
    end
end)

-- Notification function (adapted to use Library:Notify)
local function sendNotification(title, text, duration)
    Library:Notify({
        Title = title or "Nigga.lol",
        Description = text or "Notification",
        Time = duration or 3,
    })
end

-- Target notification function (adapted, but kept similar; uses Library:Notify for simplicity)
local function sendTargetNotification(plr)
    local status = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character.Humanoid.Health > 0 and "Alive" or "Dead"
    local health = plr.Character and plr.Character:FindFirstChildOfClass("Humanoid") and plr.Character.Humanoid.Health or 0
    Library:Notify({
        Title = "Target",
        Description = plr.DisplayName .. " (@" .. plr.Name .. ")\nAge: " .. plr.AccountAge .. " days\nStatus: " .. status .. " | Health: " .. math.floor(health),
        Time = 3,
    })
end

-- Remove ESP
local function removeESP(plr)
    if plr.Character then
        local char = plr.Character
        local hl = char:FindFirstChild("ESPHighlight")
        if hl then hl:Destroy() end
        local gui = char:FindFirstChild("NameESP")
        if gui then gui:Destroy() end
    end
end

-- Update ESP with tracer support
local tracerEnabled = false
local tracers = {}
local rainbowMode = true
local function updateESP(plr)
    if plr == LocalPlayer then return end
    if not plr.Character or not plr.Character:FindFirstChild("Head") then return end
    local char = plr.Character
    local head = char.Head
    
    -- Highlight
    local hl = char:FindFirstChild("ESPHighlight")
    if not hl then
        hl = Instance.new("Highlight")
        hl.Name = "ESPHighlight"
        hl.Adornee = char
        hl.FillTransparency = 0.4
        hl.OutlineTransparency = 0
        hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        hl.Parent = char
    end
    local isSelected = getgenv().YeuTuyen.SelectedTargets[plr.Name]
    hl.FillColor = rainbowMode and getRainbowColor() or (isSelected and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255))
    hl.OutlineColor = rainbowMode and getRainbowColor() or Color3.fromRGB(255, 255, 255)

    -- Name Billboard
    local gui = char:FindFirstChild("NameESP")
    if not gui then
        gui = Instance.new("BillboardGui")
        gui.Name = "NameESP"
        gui.Adornee = head
        gui.Size = UDim2.new(0, 200, 0, 30)
        gui.StudsOffset = Vector3.new(0, 2.5, 0)
        gui.AlwaysOnTop = true
        gui.Parent = char
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.Size = UDim2.new(1, 0, 1, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.TextStrokeTransparency = 0.5
        nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        nameLabel.Font = Enum.Font.SourceSansBold
        nameLabel.TextScaled = true
        nameLabel.Parent = gui
    end
    local nameLabel = gui:FindFirstChild("NameLabel")
    if nameLabel then
        nameLabel.Text = plr.DisplayName .. " (" .. plr.Name .. ")"
        nameLabel.TextColor3 = rainbowMode and getRainbowColor() or (isSelected and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255))
    end

    -- Tracer
    if tracerEnabled then
        local tracer = tracers[plr.Name]
        if not tracer then
            tracer = Drawing.new("Line")
            tracer.Thickness = 2
            tracer.Transparency = 1
            tracers[plr.Name] = tracer
        end
        local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
        if onScreen then
            tracer.Visible = true
            tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
            tracer.To = Vector2.new(screenPos.X, screenPos.Y)
            tracer.Color = rainbowMode and getRainbowColor() or (isSelected and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 255, 255))
        else
            tracer.Visible = false
        end
    else
        if tracers[plr.Name] then
            tracers[plr.Name]:Remove()
            tracers[plr.Name] = nil
        end
    end
end

-- Rainbow update
local rainbowHue = 0
RunService.RenderStepped:Connect(function()
    rainbowHue = (rainbowHue + 0.01) % 1
end)

local function getRainbowColor()
    return Color3.fromHSV(rainbowHue, 1, 1)
end

-- Hit effect (2 giây rainbow outline)
local function RainbowHitEffect(char)
    if not char then return end
    local hl = char:FindFirstChild("ESPHighlight")
    if not hl then return end

    local effect = Instance.new("Highlight")
    effect.Adornee = char
    effect.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    effect.FillTransparency = 1
    effect.OutlineTransparency = 0
    effect.Parent = char

    local t = 0
    local conn
    conn = RunService.RenderStepped:Connect(function(dt)
        if t > 2 then
            effect:Destroy()
            conn:Disconnect()
        else
            t += dt
            effect.OutlineColor = getRainbowColor()
        end
    end)
end

RunService.RenderStepped:Connect(function()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            local char = plr.Character
            local head = char and char:FindFirstChild("Head")
            local hum = char and char:FindFirstChildOfClass("Humanoid")

            if char and head and hum and hum.Health > 0 then
                -- ESP
                if getgenv().YeuTuyen.ESPEnabled then
                    local hl = char:FindFirstChild("ESPHighlight") or Instance.new("Highlight")
                    hl.Name = "ESPHighlight"
                    hl.Adornee = char
                    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                    hl.FillTransparency = 0.4
                    hl.OutlineTransparency = 0
                    hl.Parent = char

                    local gui = char:FindFirstChild("NameESP") or Instance.new("BillboardGui")
                    if not char:FindFirstChild("NameESP") then
                        gui.Name = "NameESP"
                        gui.Adornee = head
                        gui.Size = UDim2.new(0, 200, 0, 30)
                        gui.StudsOffset = Vector3.new(0, 2.5, 0)
                        gui.AlwaysOnTop = true
                        gui.Parent = char
                        local nameLabel = Instance.new("TextLabel")
                        nameLabel.Name = "NameLabel"
                        nameLabel.Size = UDim2.new(1, 0, 1, 0)
                        nameLabel.BackgroundTransparency = 1
                        nameLabel.TextStrokeTransparency = 0.5
                        nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
                        nameLabel.Font = Enum.Font.SourceSansBold
                        nameLabel.TextScaled = true
                        nameLabel.Parent = gui
                    end
                    local nameLabel = gui:FindFirstChild("NameLabel")

                    -- Kiểm tra target
                    local isTarget = getgenv().YeuTuyen.SelectedTargets[plr.Name]
                    local color = Color3.fromRGB(255, 255, 255) -- mặc định trắng
                    if isTarget then
                        color = rainbowMode and getRainbowColor() or Color3.fromRGB(0, 255, 0)
                    end

                    hl.FillColor = color
                    hl.OutlineColor = color
                    if nameLabel then
                        nameLabel.Text = plr.DisplayName .. " (" .. plr.Name .. ")"
                        nameLabel.TextColor3 = color
                    end
                else
                    local hl = char:FindFirstChild("ESPHighlight")
                    if hl then hl:Destroy() end
                    local gui = char:FindFirstChild("NameESP")
                    if gui then gui:Destroy() end
                end

                -- Tracer
                if tracerEnabled then
                    local tracer = tracers[plr.Name] or Drawing.new("Line")
                    tracers[plr.Name] = tracer
                    tracer.Thickness = 2

                    local isTarget = getgenv().YeuTuyen.SelectedTargets[plr.Name]
                    if not isTarget then
                        -- Không còn target => xoá tracer
                        if tracers[plr.Name] then
                            tracers[plr.Name]:Remove()
                            tracers[plr.Name] = nil
                        end
                    else
                        local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                        if onScreen then
                            tracer.Visible = true
                            tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                            tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                            tracer.Color = rainbowMode and getRainbowColor() or Color3.fromRGB(0, 255, 0)
                        else
                            tracer.Visible = false
                        end
                    end
                else
                    if tracers[plr.Name] then
                        tracers[plr.Name]:Remove()
                        tracers[plr.Name] = nil
                    end
                end
            else
                -- Xoá ESP + Tracer khi chết
                if tracers[plr.Name] then
                    tracers[plr.Name]:Remove()
                    tracers[plr.Name] = nil
                end
                local hl = char and char:FindFirstChild("ESPHighlight")
                if hl then hl:Destroy() end
                local gui = char and char:FindFirstChild("NameESP")
                if gui then gui:Destroy() end
            end
        end
    end

    -- Circle update
    if fovCircle.Visible and rainbowMode then
        fovCircle.Color = getRainbowColor()
    elseif fovCircle.Visible then
        fovCircle.Color = Color3.fromRGB(255, 255, 255)
    end
end)

local function checkTeam(player)
    if teamCheck and player.Team == LocalPlayer.Team then
        return true  -- cùng team => bỏ qua
    end
    return false   -- khác team => hợp lệ
end

-- GetBestTarget for Aimlock
local function GetBestTarget()
    if not getgenv().YeuTuyen or not getgenv().YeuTuyen.SelectedTargets then return end
    local bestTarget, bestPart, bestHumanoid = nil, nil, nil
    local closestDist = math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and getgenv().YeuTuyen.SelectedTargets[player.Name] and not checkTeam(player) then
            local char = player.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            local part = char and char:FindFirstChild(getgenv().YeuTuyen.Hitpart)
            if humanoid and humanoid.Health > 0 and part and not humanoid.PlatformStand then
                local bodyEffects = char:FindFirstChild("BodyEffects")
                local isKOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local isGrabbed = char:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                if not isKOd and not isGrabbed then
                    local myRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    if myRoot then
                        local dist = (myRoot.Position - part.Position).Magnitude
                        if dist < closestDist then
                            local origin = Camera.CFrame.Position
                            local direction = (part.Position - origin).Unit * 500
                            local params = RaycastParams.new()
                            params.FilterType = Enum.RaycastFilterType.Blacklist
                            params.FilterDescendantsInstances = {LocalPlayer.Character}
                            params.IgnoreWater = true
                            local result = Workspace:Raycast(origin, direction, params)
                            if result and result.Instance:IsDescendantOf(char) then
                                bestTarget = player
                                bestPart = part
                                bestHumanoid = humanoid
                                closestDist = dist
                            end
                        end
                    end
                end
            end
        end
    end
    return bestTarget, bestPart, bestHumanoid
end

-- GetAimbotTarget for Aimbot
local function GetAimbotTarget()
    local bestTarget, bestPart, bestHumanoid = nil, nil, nil
    local closestScreenDist = AIM_FOV
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local char = player.Character
            local humanoid = char and char:FindFirstChildOfClass("Humanoid")
            local part = char and char:FindFirstChild(getgenv().YeuTuyen.Hitpart)
            if humanoid and humanoid.Health > 0 and part and not humanoid.PlatformStand and not checkTeam(player) then
                local bodyEffects = char:FindFirstChild("BodyEffects")
                local isKOd = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
                local isGrabbed = char:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
                if not isKOd and not isGrabbed then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                        local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                        if screenDist <= AIM_FOV and screenDist < closestScreenDist then
                            local origin = Camera.CFrame.Position
                            local direction = (part.Position - origin).Unit * 500
                            local params = RaycastParams.new()
                            params.FilterType = Enum.RaycastFilterType.Blacklist
                            params.FilterDescendantsInstances = {LocalPlayer.Character}
                            params.IgnoreWater = true
                            local result = Workspace:Raycast(origin, direction, params)
                            if result and result.Instance:IsDescendantOf(char) then
                                bestTarget = player
                                bestPart = part
                                bestHumanoid = humanoid
                                closestScreenDist = screenDist
                            end
                        end
                    end
                end
            end
        end
    end
    return bestTarget, bestPart, bestHumanoid
end

-- Select closest to mouse
local function SelectClosestToMouse()
    local closestPlayer = nil
    local closestScreenDist = AIM_RADIUS
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                local mousePos = Vector2.new(Mouse.X, Mouse.Y)
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if dist < closestScreenDist then
                    closestScreenDist = dist
                    closestPlayer = player
                end
            end
        end
    end
    if closestPlayer then
        local name = closestPlayer.Name
        if getgenv().YeuTuyen.SelectedTargets[name] then
            getgenv().YeuTuyen.SelectedTargets[name] = nil
            sendNotification("Target", "Deselected: " .. name, 2)
            updateESP(closestPlayer)
        else
            getgenv().YeuTuyen.SelectedTargets[name] = true
            sendNotification("Target", "Selected: " .. name, 2)
            sendTargetNotification(closestPlayer)
            updateESP(closestPlayer)
        end
    else
        sendNotification("Target", "No target found near mouse!", 2)
    end
end

local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then return false end
    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then return false end
    end
    return true
end

-- Function to get nearest alive player (ignores self, checks team if enabled, uses isAlive)
local function getNearestAlivePlayer()
    local closestTarget = nil
    local closestDist = math.huge
    local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and not checkTeam(plr) and isAlive(plr) and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local dist = (myHRP.Position - plr.Character.HumanoidRootPart.Position).Magnitude
            if dist < closestDist then
                closestTarget = plr
                closestDist = dist
            end
        end
    end
    return closestTarget
end

local hitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}

local function validPart(p)
    if not p or not p.Parent or not p.Parent:FindFirstChild("Humanoid") then return false end
    local player = Players:GetPlayerFromCharacter(p.Parent)
    if not player or not getgenv().YeuTuyen.SelectedTargets[player.Name] then return false end
    for _, n in ipairs(hitParts) do
        if p.Name:lower() == n:lower() then return true end
    end
    return false
end

if not mouse1press then
    function mouse1press()
        local pos = game:GetService("UserInputService"):GetMouseLocation()
        VirtualInputManager:SendMouseButtonEvent(pos.X, pos.Y, 0, true, game, 0)
    end
end

if not mouse1release then
    function mouse1release()
        local pos = game:GetService("UserInputService"):GetMouseLocation()
        VirtualInputManager:SendMouseButtonEvent(pos.X, pos.Y, 0, false, game, 0)
    end
end

local function click()
    if UserInputService.TouchEnabled then
        local touchPos = UserInputService:GetMouseLocation()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        if mouse1press then
            mouse1press()
            mouse1release()
        elseif mouse1click then
            mouse1click()
        end
    end
end

local function distToCursor(part)
    local v, vis = Camera:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UserInputService.TouchEnabled and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) or UserInputService:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - Vector2.new(m.X, m.Y)).Magnitude
end

local function GetBestTargetPart()
    local bestPart, bestDist = nil, fovRadius
    for name, _ in pairs(getgenv().YeuTuyen.SelectedTargets) do
        local plr = Players:FindFirstChild(name)
        if plr and plr ~= LocalPlayer and isAlive(plr) and plr.Character then 
            for _, partName in ipairs(hitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

local function hideRightLegAndAddAccessories(character)
    local rightUpperLeg = character:FindFirstChild("RightUpperLeg")

    if rightUpperLeg then
        rightUpperLeg.Transparency = 1
        local rightLowerLeg = character:FindFirstChild("RightLowerLeg")
        local rightFoot = character:FindFirstChild("RightFoot")
        if rightLowerLeg then rightLowerLeg:Destroy() end
        if rightFoot then rightFoot:Destroy() end

        for _, accessory in ipairs(RightUpperLegAccessories) do
            local obj = game:GetObjects("rbxassetid://" .. tostring(accessory.id))[1]
            if obj then
                obj.Parent = workspace
                local handle = obj:FindFirstChild("Handle")
                if handle then
                    handle.CFrame = rightUpperLeg.CFrame
                    local weld = Instance.new("Weld")
                    weld.Part0 = handle
                    weld.Part1 = rightUpperLeg
                    weld.C0 = CFrame.new(0, -0.12, 0)
                    weld.Parent = handle
                    obj.Parent = character
                    table.insert(addedAccessories, obj)
                end
            end
        end
    end
end

local function restoreRightLeg(character)
    local rightUpperLeg = character:FindFirstChild("RightUpperLeg")
    if rightUpperLeg then
        rightUpperLeg.Transparency = 0
    end
    for _, acc in ipairs(addedAccessories) do
        if acc and acc.Parent then
            acc:Destroy()
        end
    end
    addedAccessories = {}
end

local function applyKorbloxAnimations()
    if runServiceConn then runServiceConn:Disconnect() end
    runServiceConn = RunService.Stepped:Connect(function()
        local char = LocalPlayer.Character
        if char and char:FindFirstChild("Animate") then
            local animate = char.Animate
            animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
            animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=10921242013"
            animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
        end
    end)
end

local function restoreAnimations()
    if runServiceConn then
        runServiceConn:Disconnect()
        runServiceConn = nil
    end
end

local function enableKorblox(character)
    task.wait(Time)
    hideRightLegAndAddAccessories(character)
    applyKorbloxAnimations()
end

local function disableKorblox(character)
    restoreRightLeg(character)
    restoreAnimations()
end

LocalPlayer.CharacterAdded:Connect(function(char)
    if korbloxEnabled then
        task.wait(1)
        enableKorblox(char)
    else
        disableKorblox(char)
    end
end)

-- Rainbow effect
local rainbowHue = 0
task.spawn(function()
    while true do
        rainbowHue = (rainbowHue + 0.01) % 1
        task.wait(0.01)
    end
end)

local function getRainbowColor()
    return Color3.fromHSV(rainbowHue, 1, 1)
end

-- Sound definitions
local sounds = {
    ["RIFK7"] = "rbxassetid://9102080552",
    ["Bubble"] = "rbxassetid://9102092728",
    ["Minecraft"] = "rbxassetid://5869422451",
    ["Cod"] = "rbxassetid://160432334",
    ["Bameware"] = "rbxassetid://6565367558",
    ["Neverlose"] = "rbxassetid://6565370984",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Yamete"] = "rbxassetid://103267082494666",
}

-- Create Sound instance
local SoundService = game:GetService("SoundService")
local hitSound = Instance.new("Sound")
hitSound.Volume = 3
hitSound.Parent = SoundService

-- Sound pool for multiple sound playback
local soundPool = {}
local soundIndex = 1

local function getNextSound()
    if soundIndex > #soundPool then
        local s = hitSound:Clone()
        s.Parent = workspace
        s.Looped = false
        table.insert(soundPool, s)
    end
    local s = soundPool[soundIndex]
    soundIndex = soundIndex + 1
    return s
end

local function playHitSound()
    local s = getNextSound()
    s:Stop()
    s:Play()
end

-- Global variable to store hit sound settings
getgenv().YeuTuyen.HitSoundEnabled = true
getgenv().YeuTuyen.HitSoundSelect = "Neverlose"

RunService.RenderStepped:Connect(function()
    if TriggerBotEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(0)
                if distToCursor(cap) <= fovRadius then
                    local origin = Camera.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
                    local result = workspace:Raycast(origin, direction, rayParams)
                    if result and result.Instance:IsDescendantOf(cap.Parent) then
                        click()
                    end
                end
            end)
        end
    end
end)

RunService.RenderStepped:Connect(function()

    if spectateEnabled then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        if not hrp then
            -- No character: reset camera and wait for respawn
            spectateEnabled = false
            Camera.CameraType = originalCameraType
            Camera.CameraSubject = originalCameraSubject
            Camera.CFrame = originalCameraCFrame
            cameraYaw = math.rad(0)
            cameraPitch = math.rad(0)
            camDistance = 5
            return
        end

        -- Determine target based on mode
        if killAuraEnabled then
            spectateTarget = getNearestAlivePlayer()
        elseif killSelectedEnabled then
            spectateTarget = getBestTargetForKill()
        end

        if spectateTarget and spectateTarget.Character and spectateTarget.Character:FindFirstChild("Head") then
            local head = spectateTarget.Character.Head
            -- Calculate camera position with rotation and dynamic distance
            local rotationCFrame = CFrame.Angles(0, cameraYaw, 0) * CFrame.Angles(cameraPitch, 0, 0)
            local cameraPos = head.Position + (rotationCFrame * Vector3.new(0, 0, camDistance))
            Camera.CFrame = CFrame.lookAt(cameraPos, head.Position)
            Camera.CameraType = Enum.CameraType.Scriptable
        else
            -- No valid target: reset camera
            spectateEnabled = false
            Camera.CameraType = originalCameraType
            Camera.CameraSubject = originalCameraSubject
            Camera.CFrame = originalCameraCFrame
            cameraYaw = math.rad(0)
            cameraPitch = math.rad(0)
            camDistance = 5
            sendNotification("Spectate", "No valid target - Camera reset", 2)
        end
    end

    if HitboxEnabled then
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Name ~= LocalPlayer.Name then
                pcall(function()
                    player.Character.getgenv().YeuTuyen.Hitpart.Size = Vector3.new(HitboxSize, HitboxSize, HitboxSize)
                    player.Character.getgenv().YeuTuyen.Hitpart.Transparency = HitboxTransparency
                    player.Character.getgenv().YeuTuyen.Hitpart.BrickColor = BrickColor.new("Really black")
                    player.Character.getgenv().YeuTuyen.Hitpart.Material = "Neon"
                    player.Character.getgenv().YeuTuyen.Hitpart.CanCollide = false
                end)
            end
        end
    else
        for _, player in ipairs(Players:GetPlayers()) do
            if player.Name ~= LocalPlayer.Name then
                pcall(function()
                    player.Character.getgenv().YeuTuyen.Hitpart.Size = Vector3.new(2, 2, 1)
                    player.Character.getgenv().YeuTuyen.Hitpart.Transparency = 1
                    player.Character.getgenv().YeuTuyen.Hitpart.BrickColor = BrickColor.new("Medium stone grey")
                    player.Character.getgenv().YeuTuyen.Hitpart.Material = "Plastic"
                    player.Character.getgenv().YeuTuyen.Hitpart.CanCollide = false
                end)
            end
        end
    end
end)

RunService.Heartbeat:Connect(function(dt)

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end  -- Skip if no character/HRP (e.g., during respawn)

    if killAuraEnabled then
        local target = getNearestAlivePlayer()
        if target then
            local targetHrp = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            if targetHrp then
                hrp.Position = targetHrp.Position + Vector3.new(0, heightOffset, 0)
            end
        end
    elseif killSelectedEnabled then
        local target = getBestTargetForKill()
        if target then
            local targetHrp = target.Character and target.Character:FindFirstChild("HumanoidRootPart")
            if targetHrp then
                hrp.Position = targetHrp.Position + Vector3.new(0, heightOffset, 0)
            end
        end
    end

    if movementEnabled then 
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hrp and hum then
            -- bước di chuyển
            local stepY = jumpPower * dt
            local stepXZ = walkSpeed * dt
            
            local moveDir = hum.MoveDirection
            if moveDir.Magnitude > 0 then
                hrp.CFrame = hrp.CFrame + (moveDir * stepXZ) + Vector3.new(0, stepY, 0)
            else
                hrp.CFrame = hrp.CFrame + Vector3.new(0, stepY, 0)
            end
        end
    end
end)

-- Aim loop
local lastTarget = nil
local lastHealth = {}

RunService.RenderStepped:Connect(function(delta)
    local target, part, hum = nil, nil, nil
    if getgenv().YeuTuyen.Mode == "Aimlock" then
        if getgenv().YeuTuyen.Status then
            target, part, hum = GetBestTarget()
        end
    elseif getgenv().YeuTuyen.Mode == "Aimbot" then
        target, part, hum = GetAimbotTarget()
        if fovCircle then
            fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        end
    end

    -- Update ESP colors for previous target
    if lastTarget and lastTarget ~= target and lastTarget.Character then
        local hl = lastTarget.Character:FindFirstChild("ESPHighlight")
        local gui = lastTarget.Character:FindFirstChild("NameESP")
        if hl then
            hl.FillColor = rainbowMode and getRainbowColor() or Color3.fromRGB(255, 255, 255)
            hl.OutlineColor = rainbowMode and getRainbowColor() or Color3.fromRGB(255, 255, 255)
        end
        if gui and gui:FindFirstChild("NameLabel") then
            gui.NameLabel.TextColor3 = rainbowMode and getRainbowColor() or Color3.fromRGB(255, 255, 255)
        end
    end

    if target and part and hum and target.Character then
        -- Chọn aimpart dựa trên CheckIfJumped
        local aimPartName = getgenv().YeuTuyen.Hitpart
        if getgenv().YeuTuyen.CheckIfJumped and hum:GetState() == Enum.HumanoidStateType.Freefall then
            aimPartName = getgenv().YeuTuyen.CheckIfJumpedAimPart
        end
        local aimPart = target.Character:FindFirstChild(aimPartName) or part 

        -- Áp dụng UseShake
        if getgenv().YeuTuyen.UseShake and aimPart then
            pcall(function()
                local shakeVec = Vector3.new(
                    math.random(-getgenv().YeuTuyen.ShakePower, getgenv().YeuTuyen.ShakePower),
                    math.random(-getgenv().YeuTuyen.ShakePower, getgenv().YeuTuyen.ShakePower),
                    math.random(-getgenv().YeuTuyen.ShakePower, getgenv().YeuTuyen.ShakePower)
                ) * 0.1
                aimPart.Velocity = aimPart.Velocity + shakeVec
                aimPart.AssemblyLinearVelocity = aimPart.AssemblyLinearVelocity + shakeVec
            end)
        end

        -- Áp dụng UnderGround
        if getgenv().YeuTuyen.UnderGround and aimPart then
            pcall(function()
                aimPart.Velocity = Vector3.new(aimPart.Velocity.X, 0, aimPart.Velocity.Z)
                aimPart.AssemblyLinearVelocity = Vector3.new(aimPart.AssemblyLinearVelocity.X, 0, aimPart.AssemblyLinearVelocity.Z)
            end)
        end

        -- Áp dụng DetectDesync
        if getgenv().YeuTuyen.DetectDesync and target.Character:FindFirstChild("HumanoidRootPart") and
            target.Character.HumanoidRootPart.Velocity.Magnitude > getgenv().YeuTuyen.Detection and aimPart then
            pcall(function()
                aimPart.Velocity = Vector3.new(0, 0, 0)
                aimPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
            end)
        end

        -- Áp dụng AutoPingSets
        if getgenv().YeuTuyen.AutoPingSets then
            pcall(function()
                local pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
                local split = string.split(pingvalue, "(")
                local ping = tonumber(split[1]) or 0
                if ping > 190 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.206547
                elseif ping > 180 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.19284
                elseif ping > 170 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.1923111
                elseif ping > 160 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.1823111
                elseif ping > 150 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.171
                elseif ping > 140 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.165773
                elseif ping > 130 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.1223333
                elseif ping > 120 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.143765
                elseif ping > 110 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.1455
                elseif ping > 100 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.130340
                elseif ping > 90 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.136
                elseif ping > 80 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.1347
                elseif ping > 70 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.119
                elseif ping > 60 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.12731
                elseif ping > 50 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.127668
                elseif ping > 40 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.125
                elseif ping > 30 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.11
                elseif ping > 20 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.12588
                elseif ping > 10 then
                    getgenv().YeuTuyen.PredictionVelocity = 0.9
                end
            end)
        end

        -- Dự đoán chuyển động
        local predictVec = aimPart.Position
        if getgenv().YeuTuyen.PredictMovement and aimPart then
            predictVec = aimPart.Position + aimPart.Velocity * getgenv().YeuTuyen.PredictionVelocity
        end

        if getgenv().YeuTuyen.Status then
            local currentLookAt = Camera.CFrame.LookVector * 1000 + Camera.CFrame.Position
            local targetLookAt = predictVec
            local lerpedLookAt = currentLookAt:Lerp(targetLookAt, AIM_SMOOTHNESS)
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, lerpedLookAt)
        end

        -- Update ESP for current target
        getgenv().YeuTuyen.SelectedTargets[target.Name] = true
        if updateESP then
            updateESP(target)
        end

        -- Show target notification
        if lastTarget ~= target and sendTargetNotification then
            sendTargetNotification(target)
        end

        -- Health change detection
        local currentHealth = hum.Health
        local prevHealth = lastHealth[target] or currentHealth
        if currentHealth < prevHealth then
            local hl = target.Character:FindFirstChild("ESPHighlight")
            if hl and getRainbowColor then
                local originalOutlineColor = hl.OutlineColor
                local originalFillColor = hl.FillColor
                hl.OutlineColor = getRainbowColor()
                if getgenv().YeuTuyen.ESPEnabled then
                    hl.FillTransparency = 0.4
                end
                task.delay(2, function()
                    if hl and hl.Parent then
                        hl.OutlineColor = originalOutlineColor
                        hl.FillColor = originalFillColor
                        hl.FillTransparency = 0.4
                    end
                end)
            end
        end
        lastHealth[target] = currentHealth
    end

    lastTarget = target
end)

-- Hàm kiểm tra xem game có K.O hoặc grab không (dựa trên việc tìm thấy BodyEffects hoặc GRABBING_CONSTRAINT)
local function hasKOOrGrabMechanic(char)
    return char:FindFirstChild("BodyEffects") or char:FindFirstChild("GRABBING_CONSTRAINT")
end

-- Handle touch start for rotation
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if spectateEnabled and input.UserInputType == Enum.UserInputType.Touch and not gameProcessedEvent then
        lastTouchPos = input.Position  -- Save initial touch position
    end
end)

-- Handle rotation (PC: mouse, Mobile: touch) and mouse wheel (PC)
UserInputService.InputChanged:Connect(function(input, gameProcessedEvent)
    if not spectateEnabled or gameProcessedEvent then return end

    if input.UserInputType == Enum.UserInputType.MouseMovement then
        -- PC: Mouse movement for rotation
        local delta = input.Delta
        cameraYaw = cameraYaw - delta.X * 0.005  -- Adjust rotation sensitivity
        cameraPitch = math.clamp(cameraPitch - delta.Y * 0.005, -math.rad(85), math.rad(85))  -- Clamp pitch
    elseif input.UserInputType == Enum.UserInputType.Touch then
        -- Mobile: Touch movement for rotation
        if lastTouchPos then
            local currentPos = input.Position
            local delta = currentPos - lastTouchPos
            cameraYaw = cameraYaw - delta.X * 0.005  -- Adjust rotation sensitivity
            cameraPitch = math.clamp(cameraPitch - delta.Y * 0.005, -math.rad(85), math.rad(85))  -- Clamp pitch
            lastTouchPos = currentPos  -- Update touch position
        end
    elseif input.UserInputType == Enum.UserInputType.MouseWheel then
        -- PC: Mouse wheel for zoom
        local zoomDelta = input.Position.Z * zoomSensitivity  -- Position.Z is 1 (forward) or -1 (backward)
        camDistance = math.clamp(camDistance - zoomDelta, minCamDistance, maxCamDistance)
    end
end)

-- Handle touch end for rotation
UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if input.UserInputType == Enum.UserInputType.Touch then
        lastTouchPos = nil  -- Reset touch position
    end
end)

-- Handle pinch gesture for zoom on mobile
UserInputService.TouchPinch:Connect(function(touchPositions, scale, velocity, state, gameProcessedEvent)
    if not spectateEnabled or gameProcessedEvent then return end
    -- Scale > 1: pinch out (zoom in), Scale < 1: pinch in (zoom out)
    local zoomDelta = (1 - scale) * zoomSensitivity * 2  -- Adjust pinch sensitivity
    camDistance = math.clamp(camDistance + zoomDelta, minCamDistance, maxCamDistance)
end)

-- Theo dõi máu để gọi hiệu ứng
local function TrackHealth(plr)
    local char = plr.Character
    if not char then return end
    local hum = char:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    local lastHealth = hum.Health
    hum.HealthChanged:Connect(function(newHealth)
        if newHealth < lastHealth then
            RainbowHitEffect(char)
            if getgenv().YeuTuyen.HitSoundEnabled then
                playHitSound()
            end
        end
        lastHealth = newHealth
    end)
end

-- Theo dõi player spawn
Players.PlayerAdded:Connect(function(plr)
    plr.CharacterAdded:Connect(function()
        task.wait(1)
        TrackHealth(plr)
    end)
end)
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        if plr.Character then TrackHealth(plr) end
        plr.CharacterAdded:Connect(function()
            task.wait(1)
            TrackHealth(plr)
        end)
    end
end

-- KO detection
local lastDowned = {}
RunService.Heartbeat:Connect(function()
    for name, _ in pairs(getgenv().YeuTuyen.SelectedTargets) do
        local plr = Players:FindFirstChild(name)
        if plr and plr.Character then
            local bodyEffects = plr.Character:FindFirstChild("BodyEffects")
            local isKO = bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value
            if isKO and not lastDowned[name] then
                lastDowned[name] = true
                sendNotification("KO Alert", name .. " just got knocked out!", 2)
            elseif not isKO then
                lastDowned[name] = false
            end
        end
    end
end)

-- Player join/leave notifications
Players.PlayerAdded:Connect(function(player)
    task.wait(1)
    if getgenv().YeuTuyen.SelectedTargets[player.Name] then
        sendNotification("Player", player.Name .. " rejoined the game.", 2)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    if getgenv().YeuTuyen.SelectedTargets[player.Name] then
        sendNotification("Player", player.Name .. " left the game.", 2)
    end
end)

LocalPlayer.CharacterAdded:Connect(function(char)
    -- Wait for HumanoidRootPart to ensure character is fully loaded
    local hrp = char:WaitForChild("HumanoidRootPart", 5)
    if not hrp then return end

    -- Save new original position and camera state
    originalPosition = hrp.Position
    originalCameraCFrame = Camera.CFrame
    originalCameraType = Camera.CameraType
    originalCameraSubject = Camera.CameraSubject

    -- Reapply KillAura or Kill Selected if enabled
    if killAuraEnabled or killSelectedEnabled then
        spectateEnabled = true  -- Re-enable spectate
        if killAuraEnabled then
            sendNotification("Kill Aura", "Resumed after respawn", 2)
        elseif killSelectedEnabled then
            sendNotification("Kill Selected", "Resumed after respawn", 2)
        end
    end
end)

-- UI Setup in Obsidian (converted from Venyx)
local aimGroup = Tabs.Main:AddLeftGroupbox("Aimbot Settings", "boxes")

aimGroup:AddButton({
    Text = "Switch Aim Mode",
    Func = function()
        if getgenv().YeuTuyen.Mode == "Aimbot" then
            getgenv().YeuTuyen.Mode = "Aimlock"
            fovCircle.Visible = false
        else
            getgenv().YeuTuyen.Mode = "Aimbot"
            fovCircle.Visible = true
        end

        -- Reset target list khi đổi chế độ
        getgenv().YeuTuyen.SelectedTargets = {}

        sendNotification("Mode Switch", "Switched to " .. getgenv().YeuTuyen.Mode .. " (Targets Cleared)", 2)
    end,
    DoubleClick = false,
    Tooltip = "Switch between Aimbot and Aimlock",
})

aimGroup:AddDropdown("AimPart", {
    Values = {"Head", "UpperTorso", "HumanoidRootPart", "Torso"},
    Default = "Head",
    Multi = false,
    Text = "Aim Part",
    Tooltip = "Select aim part",
    Callback = function(value)
        getgenv().YeuTuyen.Hitpart = value
        sendNotification("Aim Part", "Set to " .. value, 2)
    end,
})

aimGroup:AddToggle("AutoPrediction", {
    Text = "Auto Prediction",
    Default = false,
    Tooltip = "Enable auto prediction",
    Callback = function(value)
        getgenv().YeuTuyen.PredictMovement = value
        sendNotification("Auto Prediction", value and "Enabled" or "Disabled", 2)
    end,
})

aimGroup:AddToggle("TeamCheck", {
    Text = "TeamCheck",
    Default = false,
    Tooltip = "Enable team check",
    Callback = function(value)
        teamCheck = value
        sendNotification("TeamCheck", value and "Enabled" or "Disabled", 2)
    end,
})

-- FOV Circle Toggle and Slider
aimGroup:AddToggle("FOVCircle", {
    Text = "FOV Circle",
    Default = fovCircle.Visible,
    Tooltip = "Show FOV circle",
    Callback = function(value)
        fovCircle.Visible = value
    end,
})

aimGroup:AddSlider("FOVRadius", {
    Text = "FOV Radius",
    Default = AIM_FOV,
    Min = 20,
    Max = 500,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        AIM_FOV = value
        fovCircle.Radius = value
    end,
})

-- Aim Smoothness Slider
aimGroup:AddSlider("AimSmoothness", {
    Text = "Aim Smoothness",
    Default = AIM_SMOOTHNESS * 100,
    Min = 0,
    Max = 100,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        AIM_SMOOTHNESS = value / 100
    end,
})

aimGroup:AddSlider("HeightOffset", {
    Text = "Height Offset",
    Default = -8,
    Min = -50,
    Max = 200,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        heightOffset = value
        sendNotification("Height Offset", "Set to " .. value, 2)
    end
})

-- KillAura Toggle
aimGroup:AddToggle("KillAura", {
    Text = "Kill Aura",
    Default = false,
    Tooltip = "Teleport to nearest alive player with Y offset and spectate",
    Callback = function(value)
        killAuraEnabled = value
        spectateEnabled = value
        killSelectedEnabled = false  -- Disable Kill Selected to avoid conflicts
        if value then
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                originalPosition = char.HumanoidRootPart.Position
                originalCameraCFrame = Camera.CFrame
                originalCameraType = Camera.CameraType
                originalCameraSubject = Camera.CameraSubject
            end
            sendNotification("Kill Aura", "Enabled", 2)
        else
            if originalPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.Position = originalPosition
                originalPosition = nil
            end
            Camera.CameraType = originalCameraType
            Camera.CameraSubject = originalCameraSubject
            Camera.CFrame = originalCameraCFrame
            cameraYaw = math.rad(0)
            cameraPitch = math.rad(0)
            camDistance = 5
            sendNotification("Kill Aura", "Disabled", 2)
        end
    end
})

-- Kill Selected Toggle
aimGroup:AddToggle("KillSelected", {
    Text = "Kill Selected Player",
    Default = false,
    Tooltip = "Teleport to nearest selected alive player with Y offset and spectate",
    Callback = function(value)
        killSelectedEnabled = value
        spectateEnabled = value
        killAuraEnabled = false  -- Disable KillAura to avoid conflicts
        if value then
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                originalPosition = char.HumanoidRootPart.Position
                originalCameraCFrame = Camera.CFrame
                originalCameraType = Camera.CameraType
                originalCameraSubject = Camera.CameraSubject
            end
            sendNotification("Kill Selected", "Enabled", 2)
        else
            if originalPosition and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                LocalPlayer.Character.HumanoidRootPart.Position = originalPosition
                originalPosition = nil
            end
            Camera.CameraType = originalCameraType
            Camera.CameraSubject = originalCameraSubject
            Camera.CFrame = originalCameraCFrame
            cameraYaw = math.rad(0)
            cameraPitch = math.rad(0)
            camDistance = 5
            sendNotification("Kill Selected", "Disabled", 2)
        end
    end
})

aimGroup:AddToggle("Triggerbot", {
    Text = "Triggerbot",
    Default = true,
    Tooltip = "Enable triggerbot",
    Callback = function(value)
        TriggerBotEnabled = value
        sendNotification("Triggerbot", value and "ON" or "OFF")
    end,
})

-- Triggerbot FOV Radius
aimGroup:AddSlider("TriggerbotFOV", {
    Text = "Triggerbot FOV",
    Default = fovRadius,
    Min = 10,
    Max = 200,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        fovRadius = value
        sendNotification("Triggerbot", "FOV set to " .. value, 2)
    end,
})

-- HitSound Settings
local hitSoundGroup = Tabs.Main:AddRightGroupbox("HitSound Settings", "boxes")
hitSoundGroup:AddToggle("HitSoundEnabled", {
    Text = "HitSoundEnabled",
    Default = true,
    Tooltip = "Enable hit sound",
    Callback = function(value)
        getgenv().YeuTuyen.HitSoundEnabled = value
        sendNotification("HitSound", value and "Enabled" or "Disabled", 2)
    end,
})

hitSoundGroup:AddDropdown("HitSoundSelect", {
    Values = {"RIFK7", "Bubble", "Minecraft", "Cod", "Bameware", "Neverlose", "Gamesense", "Yamete"},
    Default = "Neverlose",
    Multi = false,
    Text = "HitSoundSelect",
    Tooltip = "Select hit sound",
    Callback = function(value)
        local id = sounds[value]
        if id then
            hitSound.SoundId = id
            getgenv().YeuTuyen.HitSoundSelect = value
            sendNotification("HitSound", "Selected: " .. value, 2)
        end
    end,
})

hitSoundGroup:AddToggle("Hitbox", {
    Text = "Hitbox",
    Default = false,
    Tooltip = "Enable hitbox",
    Callback = function(value)
        HitboxEnabled = value
        sendNotification("Hitbox", value and "ON" or "OFF")
    end,
})

hitSoundGroup:AddSlider("HitboxTransparency", {
    Text = "Hitbox Transparency",
    Default = 0.9,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Callback = function(value)
        HitboxTransparency = value
    end,
})

hitSoundGroup:AddSlider("HitboxSize", {
    Text = "Hitbox Size",
    Default = 15,
    Min = 5,
    Max = 50,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        HitboxSize = value
    end,
})

-- ESP Toggle
hitSoundGroup:AddToggle("ESP", {
    Text = "ESP",
    Default = getgenv().YeuTuyen.ESPEnabled,
    Tooltip = "Enable ESP",
    Callback = function(value)
        getgenv().YeuTuyen.ESPEnabled = value
        sendNotification("ESP", value and "ESP Enabled" or "ESP Disabled", 2)
    end,
})

-- Tracer Toggle
hitSoundGroup:AddToggle("Tracer", {
    Text = "Tracer",
    Default = false,
    Tooltip = "Enable tracer",
    Callback = function(value)
        tracerEnabled = value
        sendNotification("Tracer", value and "Tracer Enabled" or "Tracer Disabled", 2)
        if not value then
            for _, tracer in pairs(tracers) do
                tracer:Remove()
            end
            tracers = {}
        end
    end,
})

-- Rainbow Mode Toggle
hitSoundGroup:AddToggle("RainbowMode", {
    Text = "Rainbow Mode",
    Default = true,
    Tooltip = "Enable rainbow mode",
    Callback = function(value)
        rainbowMode = value
        sendNotification("Rainbow Mode", value and "Rainbow Mode Enabled" or "Rainbow Mode Disabled", 2)
    end,
})

hitSoundGroup:AddLabel("Set Target Key"):AddKeyPicker("SetTargetKey", {
    Default = "Q",
    SyncToggleState = false,
    Mode = "Toggle",
    NoUI = false,
    Callback = function(Value)
        SelectClosestToMouse()
    end,
    ChangedCallback = function(newKey)
        targetKey = newKey
        sendNotification("Set Target Key", "Set to " .. newKey.Name, 2)
    end,
})

hitSoundGroup:AddToggle("Movement", {
    Text = "Movement",
    Default = false,
    Tooltip = "Enable movement",
    Callback = function(value)
        movementEnabled = value
        sendNotification("Movement", value and "ON" or "OFF", 2)
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
            LocalPlayer.Character.Humanoid.UseJumpPower = true
        end
    end,
})

hitSoundGroup:AddLabel("Toggle Movement Key"):AddKeyPicker("ToggleMovementKey", {
    Default = "Z",
    SyncToggleState = false,
    Mode = "Toggle",
    NoUI = false,
    Callback = function(Value)
        movementEnabled = not movementEnabled
        sendNotification("Movement", movementEnabled and "ON" or "OFF", 2)
    end,
    ChangedCallback = function(newKey)
        sendNotification("Movement Key", "Set to " .. newKey.Name, 2)
    end,
})

-- Sliders for Movement
hitSoundGroup:AddSlider("WalkSpeed", {
    Text = "WalkSpeed",
    Default = 30,
    Min = 16,
    Max = 300,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        walkSpeed = value
    end,
})

hitSoundGroup:AddSlider("JumpPower", {
    Text = "JumpPower",
    Default = 60,
    Min = 50,
    Max = 300,
    Rounding = 0,
    Compact = false,
    Callback = function(value)
        jumpPower = value
    end,
})

hitSoundGroup:AddToggle("KeybindMenuOpen", {
    Default = Library.KeybindFrame.Visible,
    Text = "Open Keybind Menu",
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end,
})

hitSoundGroup:AddDropdown("gui scale", {
    Values = { "50%", "75%", "100%", "125%", "150%", "175%", "200%" },
    Default = "100%",
    Text = "gui scale",
    Callback = function(Value)
        Value = Value:gsub("%%", "")
        local DPI = tonumber(Value)
        Library:SetDPIScale(DPI)
    end,
})
hitSoundGroup:AddDivider()
hitSoundGroup:AddLabel("Menu bind"):AddKeyPicker("MenuKeybind", { Default = "LeftAlt", NoUI = true, Text = "Menu keybind" })

hitSoundGroup:AddButton("Unload", function()
    Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

-- Hand the library over to our managers
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("MyScriptHub")
SaveManager:SetFolder("MyScriptHub/niggalol")  -- Thay "specific-game" bằng tên game nếu muốn (ví dụ: "Da Hood")

-- Tải config trước khi build (để defaults đúng)
SaveManager:LoadAutoloadConfig()

-- Sync globals sau khi load config
syncGlobals()

-- Build sections sau load
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
