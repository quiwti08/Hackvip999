
local Players = game:GetService("Players")
local UIS     = game:GetService("UserInputService")
local Run     = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local LocalPlayer = Players.LocalPlayer
local LP      = Players.LocalPlayer
local Mouse   = LP:GetMouse()
local Cam     = workspace.CurrentCamera

-- ====== CONFIG ======
local selectKey    = Enum.KeyCode.Q
local aimlockKey   = Enum.KeyCode.H
local highlightColor = Color3.fromRGB(214,112,122)
local predictionTime = 0.17221418
local aimSmoothing = 1 -- 1 = instant; <1 = smoothing (lerp factor)
local maxSelectPx = 99999 -- no hard limit; change if you want a max selection radius

-- ====== STATE ======
local selected = {}   -- map player -> Highlight instance
local Notifications = {}
local Notifications_Frame = nil
local aimlockEnabled = true
local camlockEnabled = false
local stomptarget = false -- Bi·∫øn m·ªõi cho stomp

local possibleRemotes = {
    "MAINEVENT",
    "MainEvent",
    "Remote",
    "Packages",
    "MainRemotes"
}  

local tracer = Drawing.new("Line")
tracer.Visible = true
tracer.Thickness = 1
tracer.Color = Color3.fromRGB(255, 255, 255)

local function getMainRemote()
    if ReplicatedStorage:FindFirstChild("MainEvent") then
        return ReplicatedStorage.MainEvent
    end
    if ReplicatedStorage:FindFirstChild("MAINEVENT") then
        return ReplicatedStorage.MAINEVENT
    end

    if ReplicatedStorage:FindFirstChild("Remote") then
        return ReplicatedStorage.Remote
    end

    -- 3. MainRemotes.MainRemoteEvent
    local mainRemotes = ReplicatedStorage:FindFirstChild("MainRemotes")
    if mainRemotes and mainRemotes:FindFirstChild("MainRemoteEvent") then
        return mainRemotes.MainRemoteEvent
    end

    -- 4. Packages.Knit.Services.ToolService.RE.UpdateAim
    local packages = ReplicatedStorage:FindFirstChild("Packages")
    if packages then
        local knit = packages:FindFirstChild("Knit")
        if knit and knit:FindFirstChild("Services") then
            local toolService = knit.Services:FindFirstChild("ToolService")
            if toolService and toolService:FindFirstChild("RE") then
                local re = toolService.RE
                if re:FindFirstChild("UpdateAim") then
                    return re.UpdateAim
                end
            end
        end
    end

    -- fallback: kh√¥ng t√¨m th·∫•y
    return nil
end


local MainRemote = getMainRemote()

-- ====== HELPERS ======
local function GetDictionaryLength(t)
    local c = 0
    for _ in pairs(t) do c = c + 1 end
    return c
end

-- isAlive as you provided
local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    -- Check ri√™ng cho Da Hood (BodyEffects)
    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then
            return false
        end
    end

    return true
end

local function isKO(plr)
    return not isAlive(plr)
end

-- Notifications (non-blocking)
local function ensureNotificationsGui()
    if Notifications_Frame and Notifications_Frame.Parent then return end
    local sg = Instance.new("ScreenGui")
    sg.Name = "TB_Notifications"
    sg.ResetOnSpawn = false
    sg.Parent = game.CoreGui

    local frame = Instance.new("Frame")
    frame.Name = "Notifications"
    frame.Size = UDim2.new(0, 300, 0, 200)
    frame.Position = UDim2.new(0.5, -150, 1, -220)
    frame.BackgroundTransparency = 1
    frame.Parent = sg
    Notifications_Frame = frame
end

local function Notify(Content, Delay)
    assert(type(Content) == "string", "missing argument #1, (string expected got " .. type(Content) .. ")")
    local Delay = type(Delay) == "number" and Delay or 3
    ensureNotificationsGui()

    local Text = Instance.new("TextLabel")
    Text.Name = "Notification"
    Text.BackgroundTransparency = 1
    Text.Position = UDim2.new(0, 0, 0, GetDictionaryLength(Notifications)*22)
    Text.Size = UDim2.new(1, 0, 0, 20)
    Text.Text = Content
    Text.Font = Enum.Font.SourceSansBold
    Text.TextSize = 16
    Text.TextColor3 = Color3.new(1,1,1)
    Text.TextStrokeTransparency = 0.4
    Text.TextTransparency = 1
    Text.RichText = false
    Text.ZIndex = 5
    Text.Parent = Notifications_Frame

    local Notification = { self = Text }
    Notifications[Notification] = Notification

    local tweenIn = TweenService:Create(Text, TweenInfo.new(0.22, Enum.EasingStyle.Quad), {TextTransparency = 0})
    local tweenOut = TweenService:Create(Text, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {TextTransparency = 1})

    tweenIn:Play()
    tweenIn.Completed:Connect(function()
        task.delay(Delay, function()
            tweenOut:Play()
            tweenOut.Completed:Connect(function()
                Notifications[Notification] = nil
                if Text and Text.Parent then Text:Destroy() end
                local idx = 0
                for k,v in pairs(Notifications) do
                    local t = v.self
                    if t and t.Parent then
                        t.Position = UDim2.new(0, 0, 0, idx * 22)
                    end
                    idx = idx + 1
                end
            end)
        end)
    end)
end

-- Highlight helpers (create once, enable/disable)
local function createOrGetHighlightForPlayer(ply)
    if not ply then return nil end
    local existing = selected[ply]
    if existing and existing:IsA("Highlight") then
        return existing
    end
    local hl = Instance.new("Highlight")
    hl.Name = "TB_Highlight"
    hl.Adornee = ply.Character or nil
    hl.FillColor = highlightColor
    hl.OutlineColor = highlightColor
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    hl.Enabled = false
    hl.Parent = workspace
    selected[ply] = hl
    return hl
end

local tracers = {} -- map player -> Beam

local circles = {} 

local function createTracer(ply)
    if not LP.Character or not ply.Character then return end
    local hrp1 = LP.Character:FindFirstChild("HumanoidRootPart")
    local hrp2 = ply.Character:FindFirstChild("HumanoidRootPart")
    if not hrp1 or not hrp2 then return end

    -- N·∫øu ƒë√£ c√≥ tracer c≈© th√¨ x√≥a
    if tracers[ply] then
        tracers[ply]:Destroy()
        tracers[ply] = nil
    end

    --[[ N·∫øu ƒë√£ c√≥ v√≤ng tr√≤n c≈© th√¨ x√≥a
    if circles[ply] then
        circles[ply]:Destroy()
        circles[ply] = nil
    end]]

    -- T·∫°o tracer
    local att1 = Instance.new("Attachment", hrp1)
    local att2 = Instance.new("Attachment", hrp2)

    local beam = Instance.new("Beam")
    beam.Attachment0 = att1
    beam.Attachment1 = att2
    beam.Color = ColorSequence.new(Color3.fromRGB(214, 112, 122))
    beam.Width0 = 0.08
    beam.Width1 = 0.08
    beam.Parent = hrp1

    tracers[ply] = beam

    --[[ T·∫°o v√≤ng tr√≤n vi·ªÅn d∆∞·ªõi ch√¢n b·∫±ng SurfaceGui
    local circlePart = Instance.new("Part")
    circlePart.Name = "TargetCircle"
    circlePart.Size = Vector3.new(6, 0.1, 6) -- ƒë∆∞·ªùng k√≠nh ~ 6 studs
    circlePart.Anchored = false
    circlePart.CanCollide = false
    circlePart.Transparency = 1 -- part ·∫©n ƒëi
    circlePart.CFrame = hrp2.CFrame * CFrame.new(0, -hrp2.Size.Y/2 - 0.05, 0)
    circlePart.Parent = workspace

    -- Weld ƒë·ªÉ g·∫Øn v√†o HRP
    local weld = Instance.new("WeldConstraint")
    weld.Part0 = hrp2
    weld.Part1 = circlePart
    weld.Parent = circlePart

    -- SurfaceGui + UIStroke ƒë·ªÉ v·∫Ω v√≤ng tr√≤n vi·ªÅn
    local gui = Instance.new("SurfaceGui")
    gui.Face = Enum.NormalId.Top
    gui.AlwaysOnTop = true
    gui.Parent = circlePart

    local frame = Instance.new("Frame")
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.Position = UDim2.new(0.5, 0, 0.5, 0)
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.BackgroundTransparency = 1
    frame.Parent = gui

    local circleCorner = Instance.new("UICorner")
    circleCorner.CornerRadius = UDim.new(1, 0)
    circleCorner.Parent = frame

    local stroke = Instance.new("UIStroke")
    stroke.Thickness = 4
    stroke.Color = Color3.fromRGB(214, 112, 122)
    stroke.Parent = frame

    circles[ply] = circlePart]]

    -- C·∫≠p nh·∫≠t khi target respawn
    ply.CharacterAdded:Connect(function(newChar)
        task.wait(0.2)
        local newHrp = newChar:WaitForChild("HumanoidRootPart")

        -- c·∫≠p nh·∫≠t beam
        if tracers[ply] then
            local newAtt = Instance.new("Attachment", newHrp)
            tracers[ply].Attachment1 = newAtt
        end

        --[[ c·∫≠p nh·∫≠t circle
        if circles[ply] then
            circles[ply]:Destroy()

            local newCirclePart = Instance.new("Part")
            newCirclePart.Name = "TargetCircle"
            newCirclePart.Size = Vector3.new(6, 0.1, 6)
            newCirclePart.Anchored = false
            newCirclePart.CanCollide = false
            newCirclePart.Transparency = 1
            newCirclePart.CFrame = newHrp.CFrame * CFrame.new(0, -newHrp.Size.Y/2 - 0.05, 0)
            newCirclePart.Parent = workspace

            local newWeld = Instance.new("WeldConstraint")
            newWeld.Part0 = newHrp
            newWeld.Part1 = newCirclePart
            newWeld.Parent = newCirclePart

            local newGui = Instance.new("SurfaceGui")
            newGui.Face = Enum.NormalId.Top
            newGui.AlwaysOnTop = true
            newGui.Parent = newCirclePart

            local newFrame = Instance.new("Frame")
            newFrame.AnchorPoint = Vector2.new(0.5, 0.5)
            newFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
            newFrame.Size = UDim2.new(1, 0, 1, 0)
            newFrame.BackgroundTransparency = 1
            newFrame.Parent = newGui

            local newCorner = Instance.new("UICorner")
            newCorner.CornerRadius = UDim.new(1, 0)
            newCorner.Parent = newFrame

            local newStroke = Instance.new("UIStroke")
            newStroke.Thickness = 2
            newStroke.Color = Color3.fromRGB(214, 112, 122)
            newStroke.Parent = newFrame

            circles[ply] = newCirclePart
        end]]
    end)
end

-- S·ª≠a h√†m removeTracer ƒë·ªÉ x√≥a c·∫£ v√≤ng tr√≤n
local function removeTracer(ply)
    if tracers[ply] then
        tracers[ply]:Destroy()
        tracers[ply] = nil
    end
    --[[if circles[ply] then
        circles[ply]:Destroy()
        circles[ply] = nil
    end]]
end

-- S·ª≠a h√†m removeAllTracers ƒë·ªÉ x√≥a t·∫•t c·∫£ v√≤ng tr√≤n
local function removeAllTracers()
    for ply, beam in pairs(tracers) do
        if beam then beam:Destroy() end
    end
    --[[for ply, circle in pairs(circles) do
        if circle then circle:Destroy() end
    end]]
    tracers = {}
    --circles = {}
end

-- X·ª≠ l√Ω khi LocalPlayer h·ªìi sinh
LocalPlayer.CharacterAdded:Connect(function(newChar)
    task.wait(0.2) -- ƒê·ª£i nh√¢n v·∫≠t t·∫£i ho√†n t·∫•t
    -- X√≥a t·∫•t c·∫£ tracer v√† v√≤ng tr√≤n c≈©
    removeAllTracers()
    
    -- T√°i t·∫°o tracer v√† v√≤ng tr√≤n cho t·∫•t c·∫£ m·ª•c ti√™u ƒëang ƒë∆∞·ª£c ch·ªçn
    for ply, hl in pairs(selected) do
        if ply and hl and hl.Enabled and ply.Character then
            createTracer(ply) -- G·∫Øn l·∫°i tracer v√† v√≤ng tr√≤n
        end
    end
end)

local function addHighlightToPlayer(ply)
    if not ply then return end
    local hl = createOrGetHighlightForPlayer(ply)
    if hl then
        hl.Adornee = ply.Character or hl.Adornee
        hl.Enabled = true
    end
end

local function removeHighlightFromPlayer(ply)
    if not ply then return end
    local hl = selected[ply]
    if hl and hl:IsA("Highlight") then
        pcall(function() hl.Enabled = false end)
    end
end

local function fullyRemoveHighlight(ply)
    if not ply then return end
    local hl = selected[ply]
    if hl and hl.Destroy then
        pcall(function() hl:Destroy() end)
    end
    selected[ply] = nil
end

local function toggleSelectPlayer(ply)
    if not ply then return end
    local hl = createOrGetHighlightForPlayer(ply)
    if hl and hl.Enabled then
        removeHighlightFromPlayer(ply)
        removeTracer(ply) -- g·ª° tracer khi b·ªè ch·ªçn
        Notify(string.format("Deselected %s (@%s)", ply.DisplayName or ply.Name, ply.Name), 2)
        -- Thay ƒë·ªïi h√¨nh ·∫£nh ImageButton khi unselected
        ImageButton.Image = "rbxassetid://140623923630784"
        -- Ch·ªù 1 gi√¢y r·ªìi ƒë·ªïi l·∫°i h√¨nh ·∫£nh g·ªëc
        task.spawn(function()
            task.wait(1)
            ImageButton.Image = "rbxassetid://96086736054343"
        end)
    else
        addHighlightToPlayer(ply)
        createTracer(ply) -- t·∫°o tracer khi ch·ªçn
        Notify(string.format("Selected %s (@%s)", ply.DisplayName or ply.Name, ply.Name), 3)
        ImageButton.Image = "rbxassetid://96086736054343"
    end
end

-- Distance from world pos to mouse cursor in px (no visibility check here)
local function distToCursorFromWorldPos(pos)
    local v = Cam:WorldToViewportPoint(pos)
    local screenPos = Vector2.new(v.X, v.Y)
    local mousePos = UIS:GetMouseLocation()
    return (screenPos - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
end

-- VISIBILITY CHECK: returns true if direct line from camera to targetHead hits the target (or nothing)
local function isVisibleFromCamera(targetHead)
    if not targetHead or not targetHead.Position then return false end
    local origin = Cam.CFrame.Position
    local direction = (targetHead.Position - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    -- ignore local character so it doesn't block
    if LP.Character then
        params.FilterDescendantsInstances = {LP.Character}
    else
        params.FilterDescendantsInstances = {}
    end
    local res = workspace:Raycast(origin, direction, params)
    if not res then
        -- nothing hit => clear line
        return true
    end
    if res.Instance and res.Instance:IsDescendantOf(targetHead.Parent) then
        return true
    end
    return false
end

-- get nearest SELECTED, ALIVE, VISIBLE player to cursor (head target). returns player or nil
local function getNearestSelectedAliveVisible()
    local best, bestDist = nil, math.huge
    for ply, hl in pairs(selected) do
        if ply and hl and hl.Enabled then
            if isAlive(ply) and ply.Character then
                local head = ply.Character:FindFirstChild("Head")
                if head and head.Position then
                    if isVisibleFromCamera(head) then
                        local d = distToCursorFromWorldPos(head.Position)
                        if d < bestDist and d <= maxSelectPx then
                            bestDist = d
                            best = ply
                        end
                    end
                end
            end
        end
    end
    return best, bestDist
end

local function getNearestSelectedPlayer()
    local best, bestDist = nil, math.huge
    for ply, hl in pairs(selected) do
        if ply and hl and hl.Enabled and isAlive(ply) and ply.Character then
            local root = ply.Character:FindFirstChild("HumanoidRootPart") or ply.Character.PrimaryPart
            if root then
                local dist = (root.Position - Cam.CFrame.Position).Magnitude
                if dist < bestDist then
                    bestDist = dist
                    best = ply
                end
            end
        end
    end
    return best
end

-- cleanup when players leave
Players.PlayerRemoving:Connect(function(p)
    if selected[p] then fullyRemoveHighlight(p) end
end)

-- respawn handling
local function onCharacterAdded(char)
    local ply = Players:GetPlayerFromCharacter(char)
    if ply then
        local hl = selected[ply]
        if hl and hl:IsA("Highlight") then
            hl.Adornee = char
            -- keep enabled/disabled state as before
        end
    end
end
Players.PlayerAdded:Connect(function(p) p.CharacterAdded:Connect(onCharacterAdded) end)
for _,p in ipairs(Players:GetPlayers()) do p.CharacterAdded:Connect(onCharacterAdded) end

-- ====== SELECT INPUT ======
UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == selectKey then
            -- find nearest player to cursor (across all players) ‚Äî this is for toggling selection
            local best, bestDist = nil, math.huge
            for _,p in ipairs(Players:GetPlayers()) do
                if p ~= LP and p.Character then
                    local root = p.Character:FindFirstChild("HumanoidRootPart") or p.Character:FindFirstChild("UpperTorso") or p.Character.PrimaryPart
                    if root and root.Position then
                        local d = distToCursorFromWorldPos(root.Position)
                        if d < bestDist then
                            bestDist = d
                            best = p
                        end
                    end
                end
            end

            if best then
                toggleSelectPlayer(best)
            else
                Notify("No valid target found.", 2)
            end
            return
        end

        if input.KeyCode == aimlockKey then
            aimlockEnabled = not aimlockEnabled
            if aimlockEnabled then
                Notify("Aimlock: ON", 2)
            else
                pcall(function()
                    if LP.Character then
                        local hum = LP.Character:FindFirstChildOfClass("Humanoid")
                        if hum then Cam.CameraSubject = hum end
                    end
                end)

                for ply, hl in pairs(selected) do
                    fullyRemoveHighlight(ply) -- x√≥a highlight
                    removeTracer(ply)         -- x√≥a tracer
                end
                selected = {}
                Notify("Aimlock: OFF", 2)
            end
            return
        end
    end
end)

UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.B then
        camlockEnabled = not camlockEnabled
        if camlockEnabled then
            local target = getNearestSelectedPlayer()
            if target and target.Character then
                local head = target.Character:FindFirstChild("Head")
                if head then
                    Cam.CameraSubject = head
                    Notify("Camera locked to "..target.Name.."'s head", 2)
                else
                    camlockEnabled = false
                    Notify("Target has no head.", 2)
                end
            else
                camlockEnabled = false
                Notify("No valid target.", 2)
            end
        else
            local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                Cam.CameraSubject = hum
            end
            Notify("Camera lock disabled", 2)
        end
    end
end)

-- ch·ªçn player g·∫ßn t√¢m m√†n h√¨nh nh·∫•t
local function selectNearestPlayerToCenter()
    local center = Vector2.new(Cam.ViewportSize.X/2, Cam.ViewportSize.Y/2)
    local best, bestDist = nil, math.huge
    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= LP and p.Character then
            local root = p.Character:FindFirstChild("HumanoidRootPart") or p.Character:FindFirstChild("UpperTorso") or p.Character.PrimaryPart
            if root and root.Position then
                local v = Cam:WorldToViewportPoint(root.Position)
                local screenPos = Vector2.new(v.X, v.Y)
                local d = (screenPos - center).Magnitude
                if d < bestDist then
                    bestDist = d
                    best = p
                end
            end
        end
    end

    if best then
        toggleSelectPlayer(best)
    else
        Notify("No valid target found.", 2)
    end
end

local Sigmaballs = Instance.new("ScreenGui")
Sigmaballs.Name = "Sigmaballs"
Sigmaballs.Parent = game.CoreGui
Sigmaballs.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Sigmaballs.ResetOnSpawn = false

local ImageButton = Instance.new("ImageButton")
ImageButton.Name = "ImageButton"
ImageButton.Parent = Sigmaballs
ImageButton.Active = true
ImageButton.Draggable = true
ImageButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
ImageButton.BackgroundTransparency = 0.5
ImageButton.Size = UDim2.new(0, 90, 0, 90)
ImageButton.Image = "rbxassetid://96086736054343"
ImageButton.Position = UDim2.new(0.5, -25, 0.5, -25)

local Ui2corner = Instance.new("UICorner")
Ui2corner.CornerRadius = UDim.new(0.2, 0)
Ui2corner.Parent = ImageButton

ImageButton.MouseButton1Click:Connect(function()
    selectNearestPlayerToCenter()
end)

local dog = false -- Bi·∫øn cho WalkSpeed
local howmany = 0 -- ƒê·∫øm s·ªë n√∫t

-- [Gi·ªØ nguy√™n c√°c h√†m getMainRemote, GetDictionaryLength, isAlive, ensureNotificationsGui, Notify, v.v.]

-- [Gi·ªØ nguy√™n c√°c h√†m highlight, tracer, v√† logic ch·ªçn m·ª•c ti√™u]

-- H√†m MakeButton (ƒë√£ ch·ªânh s·ª≠a ƒë·ªÉ s·ª≠ d·ª•ng Sigmaballs)
local MakeButton = function(ButtonName, Color, callback, keycode)
    howmany = howmany + 1

    local Frame = Instance.new("Frame")
    local TextButton = Instance.new("ImageLabel")
    local TextLabel = Instance.new("TextButton")
    local UITextSizeConstraint = Instance.new("UITextSizeConstraint")

    Frame.Parent = Sigmaballs -- S·ª≠ d·ª•ng Sigmaballs thay v√¨ t·∫°o ScreenGui m·ªõi
    Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    Frame.BackgroundTransparency = 0.3
    Frame.Position = UDim2.new(0.85, -120, 0.1, (howmany - 1) * 50) -- ƒêi·ªÅu ch·ªânh v·ªã tr√≠ cho mobile
    Frame.Size = UDim2.new(0, 120, 0, 40)

    local uiStroke = Instance.new("UIStroke")
    uiStroke.Parent = Frame
    uiStroke.Color = Color
    uiStroke.Thickness = 1.2
    uiStroke.Transparency = 0

    TextButton.Parent = Frame
    TextButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    TextButton.BackgroundTransparency = 1
    TextButton.Size = UDim2.new(0, 28, 0, 28)
    TextButton.AnchorPoint = Vector2.new(0, 0.5)
    TextButton.Position = UDim2.new(0.05, 0, 0.5, 0)
    TextButton.Image = "rbxassetid://10734923214"
    TextButton.ImageColor3 = Color

    TextLabel.Parent = Frame
    TextLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    TextLabel.BackgroundTransparency = 1
    TextLabel.Size = UDim2.new(0, 80, 0, 28)
    TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
    TextLabel.Position = UDim2.new(0.65, 0, 0.5, 0)
    TextLabel.Font = Enum.Font.Arimo
    TextLabel.Text = ButtonName
    TextLabel.TextColor3 = Color
    TextLabel.TextScaled = true
    TextLabel.TextSize = 25
    TextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    TextLabel.TextStrokeTransparency = 1

    local uiCorner = Instance.new("UICorner", Frame)
    uiCorner.CornerRadius = UDim.new(0, 8)

    local buttonState = false

    TextLabel.Activated:Connect(function() -- S·ª≠ d·ª•ng Activated thay v√¨ MouseButton1Down ƒë·ªÉ h·ªó tr·ª£ mobile
        buttonState = not buttonState
        callback(buttonState)
        if buttonState then
            TextButton.Image = "rbxassetid://10735024209"
        else
            TextButton.Image = "rbxassetid://10734923214"
        end
    end)

    if keycode then
        UIS.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == keycode then
                buttonState = not buttonState
                callback(buttonState)
                if buttonState then
                    TextButton.Image = "rbxassetid://10735024209"
                else
                    TextButton.Image = "rbxassetid://10734923214"
                end
            end
        end)
    end

    local dragStart, startPos
    TextLabel.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragStart = input.Position
            startPos = Frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragStart = nil
                end
            end)
        end
    end)

    TextLabel.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            if dragStart then
                local delta = input.Position - dragStart
                Frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
            end
        end
    end)

    UITextSizeConstraint.Parent = TextLabel
    UITextSizeConstraint.MaxTextSize = 25
end

-- H√†m √°p d·ª•ng WalkSpeed & JumpPower
local function applyStats(humanoid)
    if not humanoid then return end

    if dog then
        humanoid.WalkSpeed = 150
        humanoid.JumpPower = 80
    else
        humanoid.WalkSpeed = 18
        humanoid.JumpPower = 55
    end

    -- B·∫£o v·ªá n·∫øu b·ªã game set l·∫°i
    humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if dog then
            humanoid.WalkSpeed = 150
        end
    end)
    humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if dog then
            humanoid.JumpPower = 80
        end
    end)
end

-- Khi ·∫•n n√∫t b·∫≠t/t·∫Øt
MakeButton("WalkSpeed", Color3.fromRGB(255, 255, 255), function(state)
    dog = state

    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    applyStats(humanoid)

    if dog then
        Notify("WalkSpeed ON: 150, JumpPower: 80", 2)
    else
        Notify("WalkSpeed OFF: 18, JumpPower: 55", 2)
    end
end, Enum.KeyCode.T)

-- Khi respawn, √°p d·ª•ng l·∫°i
LocalPlayer.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    applyStats(char:FindFirstChildOfClass("Humanoid"))
end)

-- S·ª≠a n√∫t Stomp
MakeButton("Stomp", Color3.fromRGB(255, 255, 255), function(state)
    stomptarget = state
    if stomptarget then
        Notify("Stomp: ON", 2)
        -- B·∫Øt ƒë·∫ßu v√≤ng l·∫∑p ki·ªÉm tra c√°c m·ª•c ti√™u K.O
        local connection
        connection = Run.Heartbeat:Connect(function()
            if not stomptarget then
                connection:Disconnect()
                return
            end

            local char = LP.Character
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            -- Duy·ªát qua c√°c m·ª•c ti√™u ƒë∆∞·ª£c ch·ªçn
            for ply, hl in pairs(selected) do
                if ply and hl and hl.Enabled and ply.Character then
                    local targetChar = ply.Character
                    local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
                    local targetHrp = targetChar:FindFirstChild("HumanoidRootPart")
                    -- Ki·ªÉm tra ƒëi·ªÅu ki·ªán b·ªè qua: m√°u b·∫±ng 0 V√Ä kh√¥ng c√≤n K.O
                    if targetHum and targetHum.Health <= 0 and not isKO(ply) then
                        print(ply.Name, "is dead and not K.O, skipping")
                        continue
                    end
                    if isKO(ply) and targetHrp then
                        local distance = (hrp.Position - targetHrp.Position).Magnitude
                        if distance <= 20 then
                            pcall(function()
                                MainRemote:FireServer("Stomp")
                            end)
                            pcall(function()
                                MainRemote:FireServer("STOMP")
                            end)
                        end
                    end
                end
            end
        end)
    else
        Notify("Stomp: OFF", 2)
        stomptarget = false
    end
end, Enum.KeyCode.K)

-- Bi·∫øn autoshoot
local tbEnabled = false
local fovRadius = 20

-- Danh s√°ch c√°c b·ªô ph·∫≠n c√≥ th·ªÉ b·∫Øn
local hitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}

-- H√†m ki·ªÉm tra b·ªô ph·∫≠n h·ª£p l·ªá
local function validPart(p)
    if not p or not p.Parent or not p.Parent:FindFirstChild("Humanoid") then return false end
    local player = Players:GetPlayerFromCharacter(p.Parent)
    if not player or not selected[player] or not selected[player].Enabled then return false end
    for _, n in ipairs(hitParts) do
        if p.Name:lower() == n:lower() then return true end
    end
    return false
end

-- H√†m t√≠nh kho·∫£ng c√°ch t·ª´ b·ªô ph·∫≠n ƒë·∫øn con tr·ªè
local function distToCursor(part)
    local v, vis = Cam:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UIS.TouchEnabled and Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2) or UIS:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - Vector2.new(m.X, m.Y)).Magnitude
end

-- H√†m gi·∫£ l·∫≠p click
local function click()
    if UIS.TouchEnabled then
        local touchPos = UIS:GetMouseLocation()
        VIM:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VIM:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        -- Ki·ªÉm tra s·ª± t·ªìn t·∫°i c·ªßa mouse1press/mouse1release ho·∫∑c mouse1click
        if mouse1press and mouse1release then
            pcall(function()
                mouse1press()
                mouse1release()
            end)
        elseif mouse1click then
            pcall(function()
                mouse1click()
            end)
        else
            -- Fallback: Gi·∫£ l·∫≠p click chu·ªôt tr√°i n·∫øu c√°c h√†m tr√™n kh√¥ng t·ªìn t·∫°i
            pcall(function()
                VIM:SendMouseButtonEvent(0, 0, 0, true) -- MouseButton1 down
                task.wait()
                VIM:SendMouseButtonEvent(0, 0, 0, false) -- MouseButton1 up
            end)
        end
    end
end

-- H√†m t√¨m b·ªô ph·∫≠n m·ª•c ti√™u t·ªët nh·∫•t
local function GetBestTargetPart()
    local bestPart, bestDist = nil, fovRadius
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and selected[plr] and selected[plr].Enabled and isAlive(plr) and plr.Character then
            for _, partName in ipairs(hitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

-- ===== CHAT COMMANDS =====
local antiStompActive = false
local flashbackActive = false
local lastPosition = nil

-- Logic AntiStomp + Flashback
local function startAntiStomp()
    local function checkAndKill(chr)
        local hum = chr:WaitForChild("Humanoid", 5)
        local bodyEffects = chr:WaitForChild("BodyEffects", 5)
        if not hum or not bodyEffects then return end
        local koValue = bodyEffects:WaitForChild("K.O", 5)
        if not koValue then return end

        local connection
        connection = Run.Heartbeat:Connect(function()
            if not antiStompActive then
                connection:Disconnect()
                return
            end
            if koValue.Value == true and hum.Health > 0 then
                if flashbackActive then
                    lastPosition = chr:GetPrimaryPartCFrame()
                end
                hum.Health = 0
            end
        end)
    end

    if LocalPlayer.Character then
        checkAndKill(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(newChar)
        if antiStompActive then
            checkAndKill(newChar)
            if flashbackActive and lastPosition then
                local root = newChar:WaitForChild("HumanoidRootPart", 5)
                if root then
                    while (root.Position - lastPosition.Position).Magnitude > 5 do
                        root.CFrame = lastPosition
                        task.wait()
                    end
                end
                lastPosition = nil
            end
        end
    end)
end

-- Th√™m n√∫t MakeButton cho autoshoot
MakeButton("AutoShoot", Color3.fromRGB(255, 255, 255), function(state)
    tbEnabled = state
    if tbEnabled then
        Notify("AutoShoot: ON", 2)
    else
        Notify("AutoShoot: OFF", 2)
    end
end, Enum.KeyCode.Z) -- Ph√≠m Z ƒë·ªÉ b·∫≠t/t·∫Øt

-- V√≤ng l·∫∑p autoshoot
Run.RenderStepped:Connect(function()
    if tbEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(0)
                if tbEnabled and distToCursor(cap) <= fovRadius then
                    local origin = Cam.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character or {}}

                    local result = workspace:Raycast(origin, direction, rayParams)

                    -- Ch·ªâ b·∫Øn n·∫øu raycast tr√∫ng ch√≠nh x√°c target (kh√¥ng b·ªã che)
                    if not result or result.Instance:IsDescendantOf(cap.Parent) then
                        if UIS.TouchEnabled and not UIS.MouseEnabled then
                            -- Mobile
                            local char = LocalPlayer.Character
                            local fired = false
                            if char then
                                for _, tool in ipairs(char:GetChildren()) do
                                    if tool:IsA("Tool") then
                                        pcall(function() tool:Activate() end)
                                        fired = true
                                        break
                                    end
                                end
                            end
                            if not fired then
                                click() -- Fallback tap
                            end
                        else
                            -- PC
                            click()
                        end
                    end
                end
            end)
        end
    end
end)

local key = Enum.KeyCode.Y

UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == key then
        local char = LP.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.Health = 0
                Notify("Died", 2)
            end
        end
    end
end)

-- ====== AIMLOCK LOOP ======
Run.RenderStepped:Connect(function(dt)

    local char = LocalPlayer.Character
    if not char then return end
    
    local tool = char:FindFirstChildWhichIsA("Tool")
    if not tool then return end

    local ammo = tool:FindFirstChild("Ammo")
    if ammo and ammo.Value <= 0 then
        -- Reload (Normal)
        MainRemote:FireServer("Reload", tool)
        task.wait(3.7)
    end

    if not aimlockEnabled then return end

    -- choose nearest selected & alive & visible target (head only)
    local target, dist = getNearestSelectedAliveVisible()
    if not target then
        return
    end

    -- get head and predict
    local head = target.Character and target.Character:FindFirstChild("Head")
    if not head then return end
    local vel = head.Velocity or Vector3.new(0,0,0)
    local predicted = head.Position + vel * predictionTime

    -- desired camera CFrame looking from current cam position to predicted point
    local camPos = Cam.CFrame.Position
    local desiredCFrame = CFrame.new(camPos, predicted)

    -- apply smoothing (alpha = aimSmoothing)
    local alpha = math.clamp(aimSmoothing, 0, 1)
    local newCFrame = Cam.CFrame:Lerp(desiredCFrame, alpha)
    pcall(function() Cam.CFrame = newCFrame end)
end)

Run.Heartbeat:Connect(function()
    local character = LocalPlayer.Character
    if character then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local movement = bodyEffects:FindFirstChild("Movement")
            if movement then
                local noJumping = movement:FindFirstChild("NoJumping")
                if noJumping then noJumping:Destroy() end
                
                local reduceWalk = movement:FindFirstChild("ReduceWalk")
                if reduceWalk then reduceWalk:Destroy() end
                
                local noWalkSpeed = movement:FindFirstChild("NoWalkSpeed")
                if noWalkSpeed then noWalkSpeed:Destroy() end
            end
            
            local reload = bodyEffects:FindFirstChild("Reload")
            if reload and reload.Value then
                reload.Value = false
            end
        end
    end
end)

local TextChatService = game:GetService("TextChatService")

local function handleCommandText(raw)
    if not raw then return end
    local msg = tostring(raw)
    msg = msg:match("^%s*(.-)%s*$") -- trim
    if msg == "" then return end
    if string.sub(msg,1,1) ~= "." then return end -- ch·ªâ x·ª≠ l√Ω l·ªánh b·∫Øt ƒë·∫ßu b·∫±ng '.'

    local body = string.sub(msg, 2)
    if body == "" then return end -- n·∫øu ch·ªâ g√µ '.' th√¨ im l·∫∑ng

    local args = {}
    for w in body:gmatch("%S+") do table.insert(args, w) end
    local cmd = string.lower(args[1] or "")
    local val = tonumber(args[2])

    -- === C√°c l·ªánh b·∫°n mu·ªën x·ª≠ l√Ω ===
    if cmd == "walkspeed" then
        if val then
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.WalkSpeed = val
                Notify("WalkSpeed set to "..val, 2)
            end
        else
            dog = not dog
            Notify("WalkSpeed toggle: "..tostring(dog), 2)
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then applyStats(hum) end
        end

    elseif cmd == "jumppower" or cmd == "jump" then
        if val then
            local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.JumpPower = val
                Notify("JumpPower set to "..val, 2)
            end
        end

    elseif cmd == "aimlock" then
        aimlockEnabled = not aimlockEnabled
        Notify("Aimlock: "..tostring(aimlockEnabled), 2)

    elseif cmd == "triggerbot" or cmd == "autoshoot" then
        tbEnabled = not tbEnabled
        Notify("TriggerBot: "..tostring(tbEnabled), 2)

    elseif cmd == "autostomp" then
        stomptarget = not stomptarget
        Notify("AutoStomp: "..tostring(stomptarget), 2)

    elseif cmd == "autoreload" then
        autoReload = not autoReload
        Notify("AutoReload: "..tostring(autoReload), 2)

    elseif cmd == "antistomp" then
        antiStompActive = not antiStompActive
        Notify("AntiStomp: "..tostring(antiStompActive), 2)
        if antiStompActive then startAntiStomp() end

    elseif cmd == "flashback" then
        flashbackActive = not flashbackActive
        Notify("Flashback: "..tostring(flashbackActive), 2)
    elseif cmd == "prediction" then
        if val then
            predictionValue = val
            Notify("Prediction set to "..val, 2)
        else
            Notify("Usage: .prediction <number>", 2)
        end
    -- üî• L·ªánh m·ªõi: FOV ch·ªânh Field of View
    elseif cmd == "fov" then
        if val then
            workspace.CurrentCamera.FieldOfView = val
            Notify("FOV set to "..val, 2)
        else
            Notify("Usage: .fov <number>", 2)
        end

    -- üî• L·ªánh m·ªõi: Reset nh√¢n v·∫≠t
    elseif cmd == "reset" then
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        if hum then
            hum.Health = 0
            Notify("Character reset!", 2)
        end
    elseif cmd ~= "" then
        -- n·∫øu b·∫Øt ƒë·∫ßu b·∫±ng '.' nh∆∞ng kh√¥ng thu·ªôc l·ªánh n√†o -> b√°o l·ªói
        Notify("Unknown command: "..cmd, 2)
    end
end

if TextChatService and TextChatService.SendingMessage then
    -- event client-side: fires khi client g·ª≠i message (th∆∞·ªùng l√† c√°i b·∫°n g√µ)
    TextChatService.SendingMessage:Connect(function(message)
        -- message l√† TextChatMessage; l·∫•y text b·∫±ng message.Text
        pcall(function()
            handleCommandText(message.Text)
        end)
    end)
else
    -- fallback (c≈©) ‚Äî c√≥ tr∆∞·ªùng h·ª£p s·∫Ω kh√¥ng fire n·∫øu game d√πng TextChatService
    LocalPlayer.Chatted:Connect(function(msg)
        pcall(function()
            handleCommandText(msg)
        end)
    end)
end

Notify("Aimlock | anhchanhm52", 2)
