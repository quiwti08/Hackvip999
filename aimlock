local Players = game:GetService("Players")
local UIS     = game:GetService("UserInputService")
local Run     = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local VIM = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local LocalPlayer = Players.LocalPlayer
local LP      = Players.LocalPlayer
local Mouse   = LP:GetMouse()
local Cam     = workspace.CurrentCamera
local rs = game:GetService("RunService")
local uis = game:GetService("UserInputService")
local lp = game.Players.LocalPlayer
local nn_nojumpcooldown = true
local customAnim = false
local inStomp = false
local instantstomp = false
local RapidFireEnabled = false
local RapidFireDelay = 0.01
local isFiring = false
local utility = {}
utility.get_gun = function()
    local char = lp.Character
    if not char then return nil end
    for _, tool in next, char:GetChildren() do
        if tool:IsA("Tool") and (tool:FindFirstChild("Ammo") or tool:FindFirstChild("AmmoCount") or tool:FindFirstChild("GunScript")) then
            return tool
        end
    end
end

utility.rapid = function(tool)
    tool:Activate()
end

-- Input bắt đầu (chuột hoặc cảm ứng)
local rapidFireConnection
rapidFireConnection = UIS.InputBegan:Connect(function(i, gp)
    if gp then return end
    if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
        local gun = utility.get_gun()
        if RapidFireEnabled and gun and not isFiring then
            isFiring = true
            task.spawn(function()
                while isFiring and RapidFireEnabled do
                    utility.rapid(gun)
                    task.wait(RapidFireDelay)
                end
            end)
            Notify("RapidFire activated", 2)
        end
    end
end)

-- Input kết thúc (chuột hoặc cảm ứng)
local rapidFireEndConnection
rapidFireEndConnection = UIS.InputEnded:Connect(function(i)
    if i.UserInputType == Enum.UserInputType.MouseButton1 or i.UserInputType == Enum.UserInputType.Touch then
        isFiring = false
        Notify("RapidFire stopped", 2)
    end
end)
if LP.Name == "anhchangm52" then
    customAnim = true
end

game:GetService("RunService").Stepped:Connect(function()
    if not inStomp and customAnim then
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("Animate") then
            char.Animate.idle.Animation1.AnimationId = "http://www.roblox.com/asset/?id=133806214992291"
            char.Animate.idle.Animation2.AnimationId = "http://www.roblox.com/asset/?id=94970088341563"
            char.Animate.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
            char.Animate.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=656117878"
            char.Animate.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
        end
    end
end)

spawn(function()
    Run.Heartbeat:Connect(function()
        if nn_nojumpcooldown then
            lp.Character.Humanoid.UseJumpPower = false
        else
            lp.Character.Humanoid.UseJumpPower = true
        end
    end)
end)

-- Danh sách animation (URL đầy đủ)
local animations = {
	C = "http://www.roblox.com/asset/?id=15609995579",
}

local currentTrack = nil
local currentKey = nil
local renderConnection = nil
local inputConnection = nil

local function setup(char)
	local hum = char:WaitForChild("Humanoid", 5)
	if not hum then return end

	local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

	-- Ngắt kết nối cũ
	if renderConnection then renderConnection:Disconnect() end
	if inputConnection then inputConnection:Disconnect() end

	-- Dừng animation nếu di chuyển
	renderConnection = rs.RenderStepped:Connect(function()
		if currentTrack and hum.MoveDirection.Magnitude > 0 then
			currentTrack:Stop()
			currentTrack = nil
			currentKey = nil
		end
	end)

	-- Nhấn phím để phát lại animation
	inputConnection = uis.InputBegan:Connect(function(input, gp)
		if gp then return end
		local key = input.KeyCode.Name
		local animId = animations[key]
		if animId and hum.MoveDirection.Magnitude == 0 then
			-- Dừng animation cũ nếu đang chạy
			if currentTrack then
				currentTrack:Stop()
				currentTrack = nil
				currentKey = nil
			end
			-- Phát animation mới
			local anim = Instance.new("Animation")
			anim.AnimationId = animId
			local track = animator:LoadAnimation(anim)
			track:Play()
			currentTrack = track
			currentKey = key
		end
	end)
end

-- Nếu đã có character
if lp.Character then
	setup(lp.Character)
end

-- Khi respawn
lp.CharacterAdded:Connect(function(char)
	currentTrack = nil
	currentKey = nil
	task.wait(0.2)
	setup(char)
end)

-- ====== CONFIG ======
local selectKey    = Enum.KeyCode.Q
local aimlockKey   = Enum.KeyCode.H
local highlightColor = Color3.fromRGB(214,112,122)
local predictionTime = 0.17221418
local aimSmoothing = 1 
local maxSelectPx = 99999 
local AutoPingSets = true
local wasAimlockEnabledBeforeKO = false

-- ====== STATE ======
local selected = {}   -- map player -> Highlight instance
local Notifications = {}
local Notifications_Frame = nil
local aimlockEnabled = true
local camlockEnabled = false
local stomptarget = false 

local possibleRemotes = {
    "MAINEVENT",
    "MainEvent",
    "Remote",
    "Packages",
    "MainRemotes"
}  

local tracer = Drawing.new("Line")
tracer.Visible = true
tracer.Thickness = 1
tracer.Color = Color3.fromRGB(255, 255, 255)

local function getMainRemote()
    if ReplicatedStorage:FindFirstChild("MainEvent") then
        return ReplicatedStorage.MainEvent
    end
    if ReplicatedStorage:FindFirstChild("MAINEVENT") then
        return ReplicatedStorage.MAINEVENT
    end

    if ReplicatedStorage:FindFirstChild("Remote") then
        return ReplicatedStorage.Remote
    end

    -- 3. MainRemotes.MainRemoteEvent
    local mainRemotes = ReplicatedStorage:FindFirstChild("MainRemotes")
    if mainRemotes and mainRemotes:FindFirstChild("MainRemoteEvent") then
        return mainRemotes.MainRemoteEvent
    end

    -- 4. Packages.Knit.Services.ToolService.RE.UpdateAim
    local packages = ReplicatedStorage:FindFirstChild("Packages")
    if packages then
        local knit = packages:FindFirstChild("Knit")
        if knit and knit:FindFirstChild("Services") then
            local toolService = knit.Services:FindFirstChild("ToolService")
            if toolService and toolService:FindFirstChild("RE") then
                local re = toolService.RE
                if re:FindFirstChild("UpdateAim") then
                    return re.UpdateAim
                end
            end
        end
    end

    -- fallback: không tìm thấy
    return nil
end

local MainRemote = getMainRemote()

-- ====== HELPERS ======
local function GetDictionaryLength(t)
    local c = 0
    for _ in pairs(t) do c = c + 1 end
    return c
end

-- isAlive as you provided
local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    -- Check riêng cho Da Hood (BodyEffects)
    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("GRABBING_CONSTRAINT")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then
            return false
        end
    end

    return true
end

local function isKO(plr)
    return not isAlive(plr)
end

-- Theo dõi trạng thái K.O và grab để tự động tắt/bật aimlock
local function monitorKOandGrab()
    local function checkStatus(char)
        local bodyEffects = char:WaitForChild("BodyEffects", 5)
        if not bodyEffects then return end
        local koValue = bodyEffects:FindFirstChild("K.O")
        local grabbedValue = bodyEffects:FindFirstChild("GRABBING_CONSTRAINT")
        if not koValue then return end

        local connection
        connection = Run.Heartbeat:Connect(function()
            if not char or not char.Parent then
                connection:Disconnect()
                return
            end

            local isKO = koValue and koValue.Value
            local isGrabbed = grabbedValue and grabbedValue.Value

            if (isKO or isGrabbed) and aimlockEnabled then
                wasAimlockEnabledBeforeKO = aimlockEnabled
                aimlockEnabled = false
            elseif not isKO and not isGrabbed and wasAimlockEnabledBeforeKO and not aimlockEnabled then
                aimlockEnabled = true
                wasAimlockEnabledBeforeKO = false
            end
        end)
    end

    if LocalPlayer.Character then
        checkStatus(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(char)
        task.wait(0.2)
        checkStatus(char)
    end)
end

-- Gọi hàm monitorKOandGrab khi script khởi động
monitorKOandGrab()

-- Notifications (non-blocking)
local function ensureNotificationsGui()
    if Notifications_Frame and Notifications_Frame.Parent then return end
    local sg = Instance.new("ScreenGui")
    sg.Name = "TB_Notifications"
    sg.ResetOnSpawn = false
    sg.Parent = game.CoreGui

    local frame = Instance.new("Frame")
    frame.Name = "Notifications"
    frame.Size = UDim2.new(0, 300, 0, 200)
    frame.Position = UDim2.new(0.5, -150, 1, -220)
    frame.BackgroundTransparency = 1
    frame.Parent = sg
    Notifications_Frame = frame
end

local function Notify(Content, Delay)
    assert(type(Content) == "string", "missing argument #1, (string expected got " .. type(Content) .. ")")
    local Delay = type(Delay) == "number" and Delay or 3
    ensureNotificationsGui()

    local Text = Instance.new("TextLabel")
    Text.Name = "Notification"
    Text.BackgroundTransparency = 1
    Text.Position = UDim2.new(0, 0, 0, GetDictionaryLength(Notifications)*22)
    Text.Size = UDim2.new(1, 0, 0, 20)
    Text.Text = Content
    Text.Font = Enum.Font.SourceSansBold
    Text.TextSize = 16
    Text.TextColor3 = Color3.new(1,1,1)
    Text.TextStrokeTransparency = 0.4
    Text.TextTransparency = 1
    Text.RichText = false
    Text.ZIndex = 5
    Text.Parent = Notifications_Frame

    local Notification = { self = Text }
    Notifications[Notification] = Notification

    local tweenIn = TweenService:Create(Text, TweenInfo.new(0.22, Enum.EasingStyle.Quad), {TextTransparency = 0})
    local tweenOut = TweenService:Create(Text, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {TextTransparency = 1})

    tweenIn:Play()
    tweenIn.Completed:Connect(function()
        task.delay(Delay, function()
            tweenOut:Play()
            tweenOut.Completed:Connect(function()
                Notifications[Notification] = nil
                if Text and Text.Parent then Text:Destroy() end
                local idx = 0
                for k,v in pairs(Notifications) do
                    local t = v.self
                    if t and t.Parent then
                        t.Position = UDim2.new(0, 0, 0, idx * 22)
                    end
                    idx = idx + 1
                end
            end)
        end)
    end)
end

-- Highlight helpers (create once, enable/disable)
local function createOrGetHighlightForPlayer(ply)
    if not ply then return nil end
    local existing = selected[ply]
    if existing and existing:IsA("Highlight") then
        return existing
    end
    local hl = Instance.new("Highlight")
    hl.Name = "TB_Highlight"
    hl.Adornee = ply.Character or nil
    hl.FillColor = highlightColor
    hl.OutlineColor = highlightColor
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    hl.Enabled = false
    hl.Parent = workspace
    selected[ply] = hl
    return hl
end

local tracers = {} -- map player -> Beam

local circles = {} 

local function createTracer(ply)
    if not LP.Character or not ply.Character then return end
    local hrp1 = LP.Character:FindFirstChild("HumanoidRootPart")
    local hrp2 = ply.Character:FindFirstChild("HumanoidRootPart")
    if not hrp1 or not hrp2 then return end

    -- Nếu đã có tracer cũ thì xóa
    if tracers[ply] then
        tracers[ply]:Destroy()
        tracers[ply] = nil
    end

    -- Tạo tracer
    local att1 = Instance.new("Attachment", hrp1)
    local att2 = Instance.new("Attachment", hrp2)

    local beam = Instance.new("Beam")
    beam.Attachment0 = att1
    beam.Attachment1 = att2
    beam.Color = ColorSequence.new(Color3.fromRGB(214, 112, 122))
    beam.Width0 = 0.08
    beam.Width1 = 0.08
    beam.Parent = hrp1

    tracers[ply] = beam

    -- Cập nhật khi target respawn
    ply.CharacterAdded:Connect(function(newChar)
        task.wait(0.2)
        local newHrp = newChar:WaitForChild("HumanoidRootPart")

        -- cập nhật beam
        if tracers[ply] then
            local newAtt = Instance.new("Attachment", newHrp)
            tracers[ply].Attachment1 = newAtt
        end
    end)
end

-- Sửa hàm removeTracer để xóa cả vòng tròn
local function removeTracer(ply)
    if tracers[ply] then
        tracers[ply]:Destroy()
        tracers[ply] = nil
    end
end

-- Sửa hàm removeAllTracers để xóa tất cả vòng tròn
local function removeAllTracers()
    for ply, beam in pairs(tracers) do
        if beam then beam:Destroy() end
    end
    tracers = {}
end

-- Xử lý khi LocalPlayer hồi sinh
LocalPlayer.CharacterAdded:Connect(function(newChar)
    task.wait(0.2) -- Đợi nhân vật tải hoàn tất
    -- Xóa tất cả tracer và vòng tròn cũ
    removeAllTracers()
    
    -- Tái tạo tracer và vòng tròn cho tất cả mục tiêu đang được chọn
    for ply, hl in pairs(selected) do
        if ply and hl and hl.Enabled and ply.Character then
            createTracer(ply) -- Gắn lại tracer và vòng tròn
        end
    end
end)

local function addHighlightToPlayer(ply)
    if not ply then return end
    local hl = createOrGetHighlightForPlayer(ply)
    if hl then
        hl.Adornee = ply.Character or hl.Adornee
        hl.Enabled = true
    end
end

local function removeHighlightFromPlayer(ply)
    if not ply then return end
    local hl = selected[ply]
    if hl and hl:IsA("Highlight") then
        pcall(function() hl.Enabled = false end)
    end
end

local function fullyRemoveHighlight(ply)
    if not ply then return end
    local hl = selected[ply]
    if hl and hl.Destroy then
        pcall(function() hl:Destroy() end)
    end
    selected[ply] = nil
end

local function toggleSelectPlayer(ply)
    if not ply then return end
    local hl = createOrGetHighlightForPlayer(ply)
    if hl and hl.Enabled then
        removeHighlightFromPlayer(ply)
        removeTracer(ply) -- gỡ tracer khi bỏ chọn
        Notify(string.format("Deselected %s (@%s)", ply.DisplayName or ply.Name, ply.Name), 2)
        -- Thay đổi hình ảnh ImageButton khi unselected
        ImageButton.Image = "rbxassetid://140623923630784"
        -- Chờ 1 giây rồi đổi lại hình ảnh gốc
        task.spawn(function()
            task.wait(1)
            ImageButton.Image = "rbxassetid://96086736054343"
        end)
    else
        addHighlightToPlayer(ply)
        createTracer(ply) -- tạo tracer khi chọn
        Notify(string.format("Selected %s (@%s)", ply.DisplayName or ply.Name, ply.Name), 3)
        ImageButton.Image = "rbxassetid://96086736054343"
    end
end

-- Distance from world pos to mouse cursor in px (no visibility check here)
local function distToCursorFromWorldPos(pos)
    local v = Cam:WorldToViewportPoint(pos)
    local screenPos = Vector2.new(v.X, v.Y)
    local mousePos = UIS:GetMouseLocation()
    return (screenPos - Vector2.new(mousePos.X, mousePos.Y)).Magnitude
end

-- VISIBILITY CHECK: returns true if direct line from camera to targetHead hits the target (or nothing)
local function isVisibleFromCamera(targetHead)
    if not targetHead or not targetHead.Position then return false end
    local origin = Cam.CFrame.Position
    local direction = (targetHead.Position - origin)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    -- ignore local character so it doesn't block
    if LP.Character then
        params.FilterDescendantsInstances = {LP.Character}
    else
        params.FilterDescendantsInstances = {}
    end
    local res = workspace:Raycast(origin, direction, params)
    if not res then
        -- nothing hit => clear line
        return true
    end
    if res.Instance and res.Instance:IsDescendantOf(targetHead.Parent) then
        return true
    end
    return false
end

-- get nearest SELECTED, ALIVE, VISIBLE player to cursor (head target). returns player or nil
local function getNearestSelectedAliveVisible()
    local best, bestDist = nil, math.huge
    for ply, hl in pairs(selected) do
        if ply and hl and hl.Enabled then
            if isAlive(ply) and ply.Character then
                local head = ply.Character:FindFirstChild("Head")
                if head and head.Position then
                    if isVisibleFromCamera(head) then
                        local d = distToCursorFromWorldPos(head.Position)
                        if d < bestDist and d <= maxSelectPx then
                            bestDist = d
                            best = ply
                        end
                    end
                end
            end
        end
    end
    return best, bestDist
end

local function getNearestSelectedPlayer()
    local best, bestDist = nil, math.huge
    for ply, hl in pairs(selected) do
        if ply and hl and hl.Enabled and isAlive(ply) and ply.Character then
            local root = ply.Character:FindFirstChild("HumanoidRootPart") or ply.Character.PrimaryPart
            if root then
                local dist = (root.Position - Cam.CFrame.Position).Magnitude
                if dist < bestDist then
                    bestDist = dist
                    best = ply
                end
            end
        end
    end
    return best
end

-- cleanup when players leave
Players.PlayerRemoving:Connect(function(p)
    if selected[p] then fullyRemoveHighlight(p) end
end)

-- respawn handling
local function onCharacterAdded(char)
    local ply = Players:GetPlayerFromCharacter(char)
    if ply then
        local hl = selected[ply]
        if hl and hl:IsA("Highlight") then
            hl.Adornee = char
            -- keep enabled/disabled state as before
        end
    end
end
Players.PlayerAdded:Connect(function(p) p.CharacterAdded:Connect(onCharacterAdded) end)
for _,p in ipairs(Players:GetPlayers()) do p.CharacterAdded:Connect(onCharacterAdded) end

-- ====== SELECT INPUT ======
UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == selectKey then
            -- find nearest player to cursor (across all players) — this is for toggling selection
            local best, bestDist = nil, math.huge
            for _,p in ipairs(Players:GetPlayers()) do
                if p ~= LP and p.Character then
                    local root = p.Character:FindFirstChild("HumanoidRootPart") or p.Character:FindFirstChild("UpperTorso") or p.Character.PrimaryPart
                    if root and root.Position then
                        local d = distToCursorFromWorldPos(root.Position)
                        if d < bestDist then
                            bestDist = d
                            best = p
                        end
                    end
                end
            end

            if best then
                toggleSelectPlayer(best)
            else
                Notify("No valid target found.", 2)
            end
            return
        end
    end
end)

local instantStompConnection
instantStompConnection = UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.E and instantstomp then
        local char = LP.Character
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if hum then
            pcall(function() MainRemote:FireServer("Stomp") end)
            pcall(function() MainRemote:FireServer("STOMP") end)

            if not stompAnimPlaying then
                local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)
                -- Ngăn Stepped loop
                inStomp = true

                -- Stop các anim đang chạy
                for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                    track:Stop()
                end

                -- Play stomp anim
                local anim = Instance.new("Animation")
                anim.AnimationId = "rbxassetid://92249489340640"
                local track = animator:LoadAnimation(anim)
                track:Play()
                stompAnimPlaying = true
                track.Stopped:Connect(function()
                    stompAnimPlaying = false
                    inStomp = false -- cho phép anim khác chạy lại
                end)
            end
        end
        return
    end
end)

UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.B then
        camlockEnabled = not camlockEnabled
        if camlockEnabled then
            local target = getNearestSelectedPlayer()
            if target and target.Character then
                local head = target.Character:FindFirstChild("Head")
                if head then
                    Cam.CameraSubject = head
                    Notify("Camera locked to "..target.Name.."'s head", 2)
                else
                    camlockEnabled = false
                    Notify("Target has no head.", 2)
                end
            else
                camlockEnabled = false
                Notify("No valid target.", 2)
            end
        else
            local hum = LP.Character and LP.Character:FindFirstChildOfClass("Humanoid")
            if hum then
                Cam.CameraSubject = hum
            end
            Notify("Camera lock disabled", 2)
        end
    end
end)

-- chọn player gần tâm màn hình nhất
local function selectNearestPlayerToCenter()
    local center = Vector2.new(Cam.ViewportSize.X/2, Cam.ViewportSize.Y/2)
    local best, bestDist = nil, math.huge
    for _,p in ipairs(Players:GetPlayers()) do
        if p ~= LP and p.Character then
            local root = p.Character:FindFirstChild("HumanoidRootPart") or p.Character:FindFirstChild("UpperTorso") or p.Character.PrimaryPart
            if root and root.Position then
                local v = Cam:WorldToViewportPoint(root.Position)
                local screenPos = Vector2.new(v.X, v.Y)
                local d = (screenPos - center).Magnitude
                if d < bestDist then
                    bestDist = d
                    best = p
                end
            end
        end
    end

    if best then
        toggleSelectPlayer(best)
    else
        Notify("No valid target found.", 2)
    end
end

local Sigmaballs = Instance.new("ScreenGui")
Sigmaballs.Name = "Sigmaballs"
Sigmaballs.Parent = game.CoreGui
Sigmaballs.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Sigmaballs.ResetOnSpawn = false


if UIS.TouchEnabled then
    local Sigmaballs = Instance.new("ScreenGui")
    Sigmaballs.Name = "Sigmaballs"
    Sigmaballs.Parent = game.CoreGui
    Sigmaballs.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Sigmaballs.ResetOnSpawn = false

    local ImageButton = Instance.new("ImageButton")
    ImageButton.Name = "ImageButton"
    ImageButton.Parent = Sigmaballs
    ImageButton.Active = true
    ImageButton.Draggable = true
    ImageButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    ImageButton.BackgroundTransparency = 0.5
    ImageButton.Size = UDim2.new(0, 90, 0, 90)
    ImageButton.Image = "rbxassetid://96086736054343"
    ImageButton.Position = UDim2.new(0.5, -25, 0.5, -25)

    local Ui2corner = Instance.new("UICorner")
    Ui2corner.CornerRadius = UDim.new(0.2, 0)
    Ui2corner.Parent = ImageButton

    ImageButton.MouseButton1Click:Connect(function()
        selectNearestPlayerToCenter()
    end)
end

local dog = false -- Biến cho WalkSpeed
local howmany = 0 -- Đếm số nút

local MakeButton
if UIS.TouchEnabled then
    -- Trên mobile: Load đầy đủ MakeButton với UI
    MakeButton = function(ButtonName, Color, callback, keycode)
        howmany = howmany + 1

        local Frame = Instance.new("Frame")
        local TextButton = Instance.new("ImageLabel")
        local TextLabel = Instance.new("TextButton")
        local UITextSizeConstraint = Instance.new("UITextSizeConstraint")

        Frame.Parent = Sigmaballs -- Sử dụng Sigmaballs đã tạo
        Frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        Frame.BackgroundTransparency = 0.3
        Frame.Position = UDim2.new(0.85, -120, 0.1, (howmany - 1) * 50)
        Frame.Size = UDim2.new(0, 120, 0, 40)

        local uiStroke = Instance.new("UIStroke")
        uiStroke.Parent = Frame
        uiStroke.Color = Color
        uiStroke.Thickness = 1.2
        uiStroke.Transparency = 0

        TextButton.Parent = Frame
        TextButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        TextButton.BackgroundTransparency = 1
        TextButton.Size = UDim2.new(0, 28, 0, 28)
        TextButton.AnchorPoint = Vector2.new(0, 0.5)
        TextButton.Position = UDim2.new(0.05, 0, 0.5, 0)
        TextButton.Image = "rbxassetid://10734923214"
        TextButton.ImageColor3 = Color

        TextLabel.Parent = Frame
        TextLabel.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        TextLabel.BackgroundTransparency = 1
        TextLabel.Size = UDim2.new(0, 80, 0, 28)
        TextLabel.AnchorPoint = Vector2.new(0.5, 0.5)
        TextLabel.Position = UDim2.new(0.65, 0, 0.5, 0)
        TextLabel.Font = Enum.Font.Arimo
        TextLabel.Text = ButtonName
        TextLabel.TextColor3 = Color
        TextLabel.TextScaled = true
        TextLabel.TextSize = 25
        TextLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
        TextLabel.TextStrokeTransparency = 1

        local uiCorner = Instance.new("UICorner", Frame)
        uiCorner.CornerRadius = UDim.new(0, 8)

        local buttonState = false

        TextLabel.Activated:Connect(function()
            buttonState = not buttonState
            callback(buttonState)
            if buttonState then
                TextButton.Image = "rbxassetid://10735024209"
            else
                TextButton.Image = "rbxassetid://10734923214"
            end
        end)

        if keycode then
            UIS.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == keycode then
                    buttonState = not buttonState
                    callback(buttonState)
                    if buttonState then
                        TextButton.Image = "rbxassetid://10735024209"
                    else
                        TextButton.Image = "rbxassetid://10734923214"
                    end
                end
            end)
        end

        local dragStart, startPos
        TextLabel.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                dragStart = input.Position
                startPos = Frame.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragStart = nil
                    end
                end)
            end
        end)

        TextLabel.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
                if dragStart then
                    local delta = input.Position - dragStart
                    Frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
                end
            end
        end)

        UITextSizeConstraint.Parent = TextLabel
        UITextSizeConstraint.MaxTextSize = 25
    end
else
    -- Trên PC: Chỉ load logic phím của MakeButton
    MakeButton = function(ButtonName, Color, callback, keycode)
        local buttonState = false
        if keycode then
            UIS.InputBegan:Connect(function(input, gameProcessed)
                if gameProcessed then return end
                if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == keycode then
                    buttonState = not buttonState
                    callback(buttonState)
                end
            end)
        end
    end
end

-- Hàm áp dụng WalkSpeed & JumpPower
local function applyStats(humanoid)
    if not humanoid then return end

    if dog then
        humanoid.WalkSpeed = 200
        humanoid.JumpPower = 80
    else
        humanoid.WalkSpeed = 18
        humanoid.JumpPower = 55
    end

    -- Bảo vệ nếu bị game set lại
    humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
        if dog then
            humanoid.WalkSpeed = 200
        end
    end)
    humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
        if dog then
            humanoid.JumpPower = 80
        end
    end)
end

-- Khi ấn nút bật/tắt
MakeButton("WalkSpeed", Color3.fromRGB(255, 255, 255), function(state)
    dog = state

    local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
    applyStats(humanoid)

    if dog then
        Notify("WalkSpeed ON", 2)
    else
        Notify("WalkSpeed OFF", 2)
    end
end, Enum.KeyCode.T)

-- Khi respawn, áp dụng lại
LocalPlayer.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid")
    applyStats(char:FindFirstChildOfClass("Humanoid"))
end)

-- Sửa nút Stomp
local stompAnimId = "rbxassetid://92249489340640"
local stompAnimTrack = nil
local stompAnimPlaying = false

local stompAnimId = "rbxassetid://92249489340640"
local stompAnimTrack = nil
local stompAnimPlaying = false

local function playStompAnim(hum)
    if not hum or stompAnimPlaying then return end -- Bỏ qua nếu không có humanoid hoặc anim đang chạy

    -- Dừng tất cả các animation hiện tại
    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
        pcall(function()
            track:Stop()
        end)
    end

    -- Tạo và chạy animation Stomp
    local anim = Instance.new("Animation")
    anim.AnimationId = stompAnimId
    stompAnimTrack = hum:LoadAnimation(anim)
    stompAnimTrack:Play()
    stompAnimPlaying = true

    -- Khi animation dừng, cho phép chạy lại
    stompAnimTrack.Stopped:Connect(function()
        stompAnimPlaying = false
        stompAnimTrack = nil -- Xóa track để tránh memory leak
        anim:Destroy() -- Xóa animation instance
    end)
end

local function toggleStomp()
    stomptarget = not stomptarget
    if stomptarget then
        Notify("Stomp: ON", 2)
        local connection
        connection = Run.Heartbeat:Connect(function()
            if not stomptarget then
                connection:Disconnect()
                return
            end

            local char = LP.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hum or not hrp then return end

            for ply, hl in pairs(selected) do
                if ply and hl and hl.Enabled and ply.Character then
                    local targetChar = ply.Character
                    local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
                    local targetHrp = targetChar:FindFirstChild("HumanoidRootPart")

                    if targetHum and targetHum.Health <= 0 and not isKO(ply) then
                        continue
                    end
                    if isKO(ply) and targetHrp then
                        local dist = (hrp.Position - targetHrp.Position).Magnitude
                        if dist <= 20 then
                            pcall(function() MainRemote:FireServer("Stomp") end)
                            pcall(function() MainRemote:FireServer("STOMP") end)
                            playStompAnim(hum) -- chạy anim
                        end
                    end
                end
            end
        end)
    else
        Notify("Stomp: OFF", 2)
        stomptarget = false
        if stompAnimTrack then
            stompAnimTrack:Stop()
            stompAnimTrack = nil
            stompAnimPlaying = false
        end
    end
end

-- Biến autoshoot
local tbEnabled = false
local fovRadius = 20

-- Danh sách các bộ phận có thể bắn
local hitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}

-- Biến hitpart cho aimlock (mặc định là Head)
local currentHitPart = "Head"

-- Hàm kiểm tra bộ phận hợp lệ
local function validPart(p)
    if not p or not p.Parent or not p.Parent:FindFirstChild("Humanoid") then return false end
    local player = Players:GetPlayerFromCharacter(p.Parent)
    if not player or not selected[player] or not selected[player].Enabled then return false end
    for _, n in ipairs(hitParts) do
        if p.Name:lower() == n:lower() then return true end
    end
    return false
end

-- Hàm tính khoảng cách từ bộ phận đến con trỏ
local function distToCursor(part)
    local v, vis = Cam:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UIS.TouchEnabled and Vector2.new(Cam.ViewportSize.X / 2, Cam.ViewportSize.Y / 2) or UIS:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - Vector2.new(m.X, m.Y)).Magnitude
end

-- Hàm giả lập click
local function click()
    if UIS.TouchEnabled then
        local touchPos = UIS:GetMouseLocation()
        VIM:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VIM:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        -- Kiểm tra sự tồn tại của mouse1press/mouse1release hoặc mouse1click
        if mouse1press and mouse1release then
            pcall(function()
                mouse1press()
                mouse1release()
            end)
        elseif mouse1click then
            pcall(function()
                mouse1click()
            end)
        else
            -- Fallback: Giả lập click chuột trái nếu các hàm trên không tồn tại
            pcall(function()
                VIM:SendMouseButtonEvent(0, 0, 0, true) -- MouseButton1 down
                task.wait()
                VIM:SendMouseButtonEvent(0, 0, 0, false) -- MouseButton1 up
            end)
        end
    end
end

-- Hàm tìm bộ phận mục tiêu tốt nhất
local function GetBestTargetPart()
    local bestPart, bestDist = nil, fovRadius
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and selected[plr] and selected[plr].Enabled and isAlive(plr) and plr.Character then
            for _, partName in ipairs(hitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

-- ===== CHAT COMMANDS =====
local antiStompActive = false
local flashbackActive = false
local lastPosition = nil

-- Logic AntiStomp + Flashback
local function startAntiStomp()
    local function checkAndKill(chr)
        local hum = chr:WaitForChild("Humanoid", 5)
        local bodyEffects = chr:WaitForChild("BodyEffects", 5)
        if not hum or not bodyEffects then return end
        local koValue = bodyEffects:WaitForChild("K.O", 5)
        if not koValue then return end

        local connection
        connection = Run.Heartbeat:Connect(function()
            if not antiStompActive then
                connection:Disconnect()
                return
            end
            if koValue.Value == true and hum.Health > 0 then
                if flashbackActive then
                    lastPosition = chr:GetPrimaryPartCFrame()
                end
                hum.Health = 0
            end
        end)
    end

    if LocalPlayer.Character then
        checkAndKill(LocalPlayer.Character)
    end
    LocalPlayer.CharacterAdded:Connect(function(newChar)
        if antiStompActive then
            checkAndKill(newChar)
            if flashbackActive and lastPosition then
                local root = newChar:WaitForChild("HumanoidRootPart", 5)
                if root then
                    while (root.Position - lastPosition.Position).Magnitude > 5 do
                        root.CFrame = lastPosition
                        task.wait()
                    end
                end
                lastPosition = nil
            end
        end
    end)
end

-- Biến autoshoot
local autoReload = true -- Mặc định on cho autoreload

-- Thêm nút MakeButton cho autoshoot
MakeButton("AutoShoot", Color3.fromRGB(255, 255, 255), function(state)
    tbEnabled = state
    if tbEnabled then
        Notify("AutoShoot: ON", 2)
    else
        Notify("AutoShoot: OFF", 2)
    end
end, Enum.KeyCode.Z) -- Phím Z để bật/tắt

-- Vòng lặp autoshoot
Run.RenderStepped:Connect(function()
    if tbEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(0)
                if tbEnabled and distToCursor(cap) <= fovRadius then
                    local origin = Cam.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character or {}}

                    local result = workspace:Raycast(origin, direction, rayParams)

                    -- Chỉ bắn nếu raycast trúng chính xác target (không bị che)
                    if not result or result.Instance:IsDescendantOf(cap.Parent) then
                        if UIS.TouchEnabled and not UIS.MouseEnabled then
                            -- Mobile
                            local char = LocalPlayer.Character
                            local fired = false
                            if char then
                                for _, tool in ipairs(char:GetChildren()) do
                                    if tool:IsA("Tool") then
                                        pcall(function() tool:Activate() end)
                                        fired = true
                                        break
                                    end
                                end
                            end
                            if not fired then
                                click() -- Fallback tap
                            end
                        else
                            -- PC
                            click()
                        end
                    end
                end
            end)
        end
    end
end)

local key = Enum.KeyCode.Y

UIS.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == key then
        local char = LP.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.Health = 0
                Notify("Died", 2)
            end
        end
    end
end)

Run.Heartbeat:Connect(function()
    if AutoPingSets then
        -- Lấy giá trị ping
        local pingvalue, ping
        local success = pcall(function()
            pingvalue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
            local split = string.split(pingvalue, "(")
            ping = tonumber(split[1])
        end)
        if not success or not ping then
            ping = 60 -- Giá trị mặc định nếu lỗi
        end

        -- Gán predictionTime dựa trên ping (sử dụng giá trị từ closePredictions)
        if ping > 450 then
            predictionTime = 0.1850
        elseif ping > 400 then
            predictionTime = 0.1800
        elseif ping > 350 then
            predictionTime = 0.1750
        elseif ping > 300 then
            predictionTime = 0.1700
        elseif ping > 280 then
            predictionTime = 0.165771
        elseif ping > 270 then
            predictionTime = 0.16780
        elseif ping > 260 then
            predictionTime = 0.195566
        elseif ping > 250 then
            predictionTime = 0.175566
        elseif ping > 240 then
            predictionTime = 0.1651
        elseif ping > 230 then
            predictionTime = 0.16780
        elseif ping > 220 then
            predictionTime = 0.15692
        elseif ping > 210 then
            predictionTime = 0.165566
        elseif ping > 200 then
            predictionTime = 0.165566
        elseif ping > 190 then
            predictionTime = 0.16942
        elseif ping > 180 then
            predictionTime = 0.166547
        elseif ping > 170 then
            predictionTime = 0.19284
        elseif ping > 160 then
            predictionTime = 0.1923111
        elseif ping > 150 then
            predictionTime = 0.16
        elseif ping > 140 then
            predictionTime = 0.15
        elseif ping > 130 then
            predictionTime = 0.153
        elseif ping > 120 then
            predictionTime = 0.151
        elseif ping > 110 then
            predictionTime = 0.149
        elseif ping > 100 then
            predictionTime = 0.1475
        elseif ping > 90 then
            predictionTime = 0.1446
        elseif ping > 80 then
            predictionTime = 0.1403
        elseif ping > 70 then
            predictionTime = 0.13892
        elseif ping > 60 then
            predictionTime = 0.13598
        elseif ping > 50 then
            predictionTime = 0.1357
        elseif ping > 40 then
            predictionTime = 0.13544
        elseif ping > 30 then
            predictionTime = 0.1130
        elseif ping > 20 then
            predictionTime = 0.10036
        else
            predictionTime = 0.12588
        end
    end
end)

-- ====== AIMLOCK LOOP ======
Run.RenderStepped:Connect(function(dt)

    local char = LocalPlayer.Character
    if not char then return end
    
    local tool = char:FindFirstChildWhichIsA("Tool")
    if not tool then return end

    local ammo = tool:FindFirstChild("Ammo")
    if ammo and ammo.Value <= 0 and autoReload then
        -- Reload (Normal)
        MainRemote:FireServer("Reload", tool)
        task.wait(3.7)
    end

    if not aimlockEnabled then return end

    -- choose nearest selected & alive & visible target (head only)
    local target, dist = getNearestSelectedAliveVisible()
    if not target then
        return
    end

    -- get head and predict
    local targetPart = target.Character and target.Character:FindFirstChild(currentHitPart)
    if not targetPart then return end

    pcall(function()
        targetPart.Velocity = Vector3.new(targetPart.Velocity.X, 0, targetPart.Velocity.Z)
        targetPart.AssemblyLinearVelocity = Vector3.new(targetPart.AssemblyLinearVelocity.X, 0, targetPart.AssemblyLinearVelocity.Z)
    end)

    if target.Character:FindFirstChild("HumanoidRootPart") and
        target.Character.HumanoidRootPart.Velocity.Magnitude > targetPart.Velocity.Magnitude then
        pcall(function()
            targetPart.Velocity = Vector3.new(0, 0, 0)
            targetPart.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
        end)
    end
    
    local vel = targetPart.Velocity or Vector3.new(0,0,0)
    local predicted = targetPart.Position + vel * predictionTime

    -- desired camera CFrame looking from current cam position to predicted point
    local camPos = Cam.CFrame.Position
    local desiredCFrame = CFrame.new(camPos, predicted)

    -- apply smoothing (alpha = aimSmoothing)
    local alpha = math.clamp(aimSmoothing, 0, 1)
    local newCFrame = Cam.CFrame:Lerp(desiredCFrame, alpha)
    pcall(function() Cam.CFrame = newCFrame end)
end)

Run.Heartbeat:Connect(function()
    local character = LocalPlayer.Character
    if character then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        if bodyEffects then
            local movement = bodyEffects:FindFirstChild("Movement")
            if movement then
                local noJumping = movement:FindFirstChild("NoJumping")
                if noJumping then noJumping:Destroy() end
                
                local reduceWalk = movement:FindFirstChild("ReduceWalk")
                if reduceWalk then reduceWalk:Destroy() end
                
                local noWalkSpeed = movement:FindFirstChild("NoWalkSpeed")
                if noWalkSpeed then noWalkSpeed:Destroy() end
            end
            
            local reload = bodyEffects:FindFirstChild("Reload")
            if reload and reload.Value then
                reload.Value = false
            end
        end
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local TeleportService = game:GetService("TeleportService")
local TextChatService = game:GetService("TextChatService")

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = game:GetService("Players").LocalPlayer

desync_setback = Instance.new("Part")
desync_setback.Name = "Desync Setback"
desync_setback.Parent = workspace
desync_setback.Size = Vector3.new(2, 2, 1)
desync_setback.CanCollide = false
desync_setback.Anchored = true
desync_setback.Transparency = 1

desync = {
    enabled = false,
    mode = "DestroyCheaters",
    teleportCFrame = CFrame.new(0, 0, 0),
    old_position = nil,
    voidSpamActive = false,
    toggleEnabled = false
}

function resetCamera()
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            workspace.CurrentCamera.CameraSubject = humanoid
        end
    end
end

function toggleDesync(state)
    desync.enabled = state
    if desync.enabled then
        workspace.CurrentCamera.CameraSubject = desync_setback
    else
        resetCamera()
    end
end

function setDesyncMode(mode)
    desync.mode = mode
end

RunService.Heartbeat:Connect(function()
    if desync.enabled and LocalPlayer.Character then
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            desync.old_position = rootPart.CFrame

            local teleportPosition = Vector3.new(0, 0, 0)
            local teleportRotation = CFrame.new()

            if desync.mode == "DestroyCheaters" then
                teleportPosition = Vector3.new(11223344556677889900, 1, 1)

            elseif desync.mode == "Underground" then
                teleportPosition = rootPart.Position - Vector3.new(0, 12, 0)

            elseif desync.mode == "VoidSpam" then
                teleportPosition = math.random(1, 2) == 1 and desync.old_position.Position or Vector3.new(
                    math.random(10000, 50000),
                    math.random(10000, 50000),
                    math.random(10000, 50000)
                )

            elseif desync.mode == "Void" then
                teleportPosition = Vector3.new(
                    rootPart.Position.X + math.random(-444444, 444444),
                    rootPart.Position.Y + math.random(-444444, 444444),
                    rootPart.Position.Z + math.random(-44444, 44444)
                )

            elseif desync.mode == "Player" then
                local target = getNearestSelectedAliveVisible()
                if not target then
                    desync.enabled = false
                    Notify("No valid target for Player mode, desync disabled.", 2)
                    return
                end
                local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
                if targetRoot then
                    local offset = Vector3.new(math.random(-20, 20), math.random(-10, 10), math.random(-20, 20))
                    teleportPosition = targetRoot.Position + offset
                    teleportRotation = CFrame.Angles(
                        math.rad(math.random(0, 360)),
                        math.rad(math.random(0, 360)),
                        math.rad(math.random(0, 360))
                    )
                else
                    desync.enabled = false
                    Notify("Target has no HumanoidRootPart, desync disabled.", 2)
                    return
                end
            end

            desync.teleportCFrame = CFrame.new(teleportPosition) * teleportRotation

            if desync.mode ~= "Rotation" then
                rootPart.CFrame = desync.teleportCFrame
                workspace.CurrentCamera.CameraSubject = desync_setback

                RunService.RenderStepped:Wait()

                desync_setback.CFrame = desync.old_position * CFrame.new(0, rootPart.Size.Y / 2 + 0.5, 0)
                rootPart.CFrame = desync.old_position
            end
        end
    end
end)

-- Thêm nút Desync
MakeButton("Desync", Color3.fromRGB(255, 255, 255), function(state)
    toggleDesync(state)
    Notify("Desync: " .. (state and "ON" or "OFF"), 2)
end, Enum.KeyCode.V)

monitorKOandGrab()

LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.2)
    checkStatus(char)
end)

-- Load LinoriaLib và các addon
local repo = 'https://raw.githubusercontent.com/mstudio45/LinoriaLib/main/'
local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()
local Options = Library.Options
local Toggles = Library.Toggles

-- Cài đặt Library cho mobile
Library.ShowToggleFrameInKeybinds = true -- Hỗ trợ nút toggle trong UI keybinds, phù hợp cho mobile
Library.ShowCustomCursor = true -- Bật con trỏ tùy chỉnh
Library.NotifySide = "Left" -- Thông báo hiển thị bên trái

-- Tạo Window
local Window = Library:CreateWindow({
    Title = 'Betuyen.cc | anhchangm52',
    Center = true,
    AutoShow = true,
    Resizable = true,
    ShowCustomCursor = true,
    UnlockMouseWhileOpen = true,
    NotifySide = "Left",
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- Tạo các Tab
local Tabs = {
    Main = Window:AddTab('Main'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- === Tab Main ===
-- Groupbox Aimlock (Bên trái)
local AimSection = Tabs.Main:AddLeftGroupbox('Aimlock')

AimSection:AddToggle('AimlockToggle', {
    Text = 'Aimlock',
    Default = aimlockEnabled,
    Tooltip = 'Toggle aimlock functionality',
    Callback = function(state)
        aimlockEnabled = state
        Library:Notify('Aimlock: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

AimSection:AddToggle('AutoPingSetToggle', {
    Text = 'Auto Ping Set',
    Default = AutoPingSets,
    Tooltip = 'Automatically adjust prediction based on ping',
    Callback = function(state)
        AutoPingSets = state
        Library:Notify('Auto Ping Set: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

AimSection:AddInput('PredictionInput', {
    Text = 'Prediction',
    Default = tostring(predictionTime),
    Numeric = true,
    Tooltip = 'Set prediction time for aimlock',
    Placeholder = 'Enter prediction time',
    Callback = function(value)
        local num = tonumber(value)
        if num then
            predictionTime = num
            Library:Notify('Prediction set to ' .. num, 2)
        else
            Library:Notify('Invalid prediction value', 2)
        end
    end
})

AimSection:AddDropdown('HitpartDropdown', {
    Text = 'Hitpart',
    Values = hitParts,
    Default = currentHitPart,
    Tooltip = 'Select target hitpart for aimlock',
    Callback = function(value)
        currentHitPart = value
        Library:Notify('Hitpart set to ' .. value, 2)
    end
})

-- Groupbox Misc (Bên phải)
local MiscSection = Tabs.Main:AddRightGroupbox('Misc')

MiscSection:AddSlider('FOVSlider', {
    Text = 'FOV',
    Default = workspace.CurrentCamera.FieldOfView,
    Min = 40,
    Max = 120,
    Rounding = 0,
    Tooltip = 'Adjust camera field of view',
    Callback = function(value)
        workspace.CurrentCamera.FieldOfView = value
        Library:Notify('FOV set to ' .. value, 2)
    end
})

MiscSection:AddToggle('AutoreloadToggle', {
    Text = 'Autoreload',
    Default = autoReload,
    Tooltip = 'Toggle automatic reload',
    Callback = function(state)
        autoReload = state
        Library:Notify('Autoreload: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddToggle('AutostompToggle', {
    Text = 'Autostomp',
    Default = stomptarget,
    Tooltip = 'Toggle automatic stomp on selected targets',
    Callback = function(state)
        stomptarget = state
        toggleStomp()
    end
})

MiscSection:AddToggle('AntistompToggle', {
    Text = 'Antistomp',
    Default = antiStompActive,
    Tooltip = 'Prevent being stomped',
    Callback = function(state)
        antiStompActive = state
        Library:Notify('Antistomp: ' .. (state and 'ON' or 'OFF'), 2)
        if antiStompActive then startAntiStomp() end
    end
})

MiscSection:AddToggle('FlashbackToggle', {
    Text = 'Flashback',
    Default = flashbackActive,
    Tooltip = 'Enable flashback on death',
    Callback = function(state)
        flashbackActive = state
        Library:Notify('Flashback: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddToggle('NoSlowdownToggle', {
    Text = 'No Slowdown',
    Default = true,
    Tooltip = 'Prevent movement slowdown',
    Callback = function(state)
        Library:Notify('No Slowdown: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddToggle('NoJumpCooldownToggle', {
    Text = 'No Jump Cooldown',
    Default = nn_nojumpcooldown,
    Tooltip = 'Remove jump cooldown',
    Callback = function(state)
        nn_nojumpcooldown = state
        Library:Notify('No Jump Cooldown: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddToggle('RapidFireToggle', {
    Text = 'Rapid Fire',
    Default = RapidFireEnabled,
    Tooltip = 'Enable rapid fire for weapons',
    Callback = function(state)
        RapidFireEnabled = state
        Library:Notify('Rapid Fire: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddToggle('InstantstompToggle', {
    Text = 'Instantstomp (PC)',
    Default = instantstomp,
    Tooltip = 'Enable instant stomp (PC only)',
    Callback = function(state)
        instantstomp = state
        Library:Notify('Instantstomp: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddToggle('CustomAnimToggle', {
    Text = 'Custom Animation',
    Default = customAnim,
    Tooltip = 'Enable custom animations',
    Callback = function(state)
        customAnim = state
        Library:Notify('Custom Animation: ' .. (state and 'ON' or 'OFF'), 2)
    end
})

MiscSection:AddButton({
    Text = 'Copy HelloKitty Crosshair ID',
    Func = function()
        pcall(function()
            setclipboard("10639756312")
            Library:Notify('Copied Hello Kitty Crosshair ID: 10639756312', 2)
        end)
    end,
    Tooltip = 'Copies the Hello Kitty crosshair ID to clipboard'
})

-- Thêm Dropdown cho Desync Method
MiscSection:AddDropdown('DesyncMethodDropdown', {
    Text = 'Desync Method',
    Values = { 'DestroyCheaters', 'Underground', 'VoidSpam', 'Void', 'Player' },
    Default = desync.mode,
    Tooltip = 'Select desync method',
    Callback = function(value)
        setDesyncMode(value)
        Library:Notify('Desync Method set to: ' .. value, 2)
    end
})

-- === Tab UI Settings ===
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddToggle('KeybindMenuToggle', {
    Text = 'Open Keybind Menu',
    Default = Library.KeybindFrame.Visible,
    Tooltip = 'Toggle keybind menu visibility',
    Callback = function(value)
        Library.KeybindFrame.Visible = value
    end
})

MenuGroup:AddToggle('CustomCursorToggle', {
    Text = 'Custom Cursor',
    Default = Library.ShowCustomCursor,
    Tooltip = 'Toggle custom cursor',
    Callback = function(value)
        Library.ShowCustomCursor = value
    end
})

MenuGroup:AddDivider()

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'RightShift',
    NoUI = true,
    Text = 'Menu keybind',
    Callback = function(value)
        Library:Notify('Menu keybind changed to: ' .. tostring(value), 2)
    end
})

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function()
        Library:Unload()
        Library:Notify('Unloaded script', 2)
    end,
    Tooltip = 'Unload the script'
})

MenuGroup:AddButton({
    Text = 'Rejoin',
    Func = function()
        Library:Notify('Rejoining...', 2)
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
    end,
    Tooltip = 'Rejoin the current server'
})

-- Cài đặt ThemeManager và SaveManager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })
ThemeManager:SetFolder('BetuyenHub')
SaveManager:SetFolder('BetuyenHub/DaHood')
SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])
SaveManager:LoadAutoloadConfig()

-- Thiết lập phím toggle menu
Library.ToggleKeybind = Options.MenuKeybind

-- Watermark động
local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    FrameCounter = FrameCounter + 1
    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end
    Library:SetWatermark(('Betuyen.cc | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ))
end)

-- Xử lý unload
Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    Library:Notify('Unloaded!', 2)
    Library.Unloaded = true
end)

-- Thông báo khởi động
Library:Notify('Betuyen.cc | anhchangm52 Loaded!', 10)
