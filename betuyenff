--// Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local LocalizationService = game:GetService("LocalizationService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Lighting = game:GetService("Lighting")
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local StarterGui = game:GetService("StarterGui")
local Camera = Workspace.CurrentCamera
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")

local TextChatService = game:GetService("TextChatService")

local chatWindow = TextChatService:FindFirstChild("ChatWindowConfiguration")
if chatWindow then
    chatWindow.Enabled = true -- Bật lại chat window
end

--// GUI Setup
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local gui = Instance.new("ScreenGui")
gui.Name = "DhuyxMenu"
gui.ResetOnSpawn = false
gui.IgnoreGuiInset = true
gui.Parent = playerGui

--// Config
local Config = { 
    CustomPing = nil,
    Buttons = {}, 
    ESPEnabled = false,
    SpeedEnabled = false,
    FlyEnabled = false,
    AimbotEnabled = false,
    FullbrightEnabled = false,
    NoclipEnabled = false,
    ShiftAmount = 0.5,
    SelectedPlayers = {},
    FlySpeed = 35,
    SpeedAmount = 20,
    clickTpEnabled = false,
    MacroLegitEnabled = false,
    AntiLockEnabled = false,
    AntiLockType = "Behind",
    LookAtEnabled = false,
    CsyncRandomEnabled = false,
    CsyncOrbitEnabled = false,
    CsyncRadius = 10,
    CsyncHeight = 5,
    CsyncSpeed = 2,
    RainbowHitEffectEnabled = true,
    AutoWallhopEnabled = false,
    SpinbotEnabled = false,
    SpinbotSpeed = 450,
    AutoPredictionEnabled = false,
    Unlock3rdEnabled = false,
    Prediction = nil,
}
local Keybinds = {}

--// Helpers
local function attachButtonEffects(btn, shrinkPx)
    local orig = btn.Size
    btn.MouseEnter:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(200, 200, 200)}):Play()
    end)
    btn.MouseLeave:Connect(function()
        TweenService:Create(btn, TweenInfo.new(0.15), {BackgroundColor3 = Color3.fromRGB(180, 180, 180)}):Play()
    end)
    btn.MouseButton1Click:Connect(function()
        local s = shrinkPx or 3
        local toSmall = UDim2.new(orig.X.Scale, math.max(0, orig.X.Offset - s), orig.Y.Scale, math.max(0, orig.Y.Offset - s))
        local t1 = TweenService:Create(btn, TweenInfo.new(0.08), {Size = toSmall})
        local t2 = TweenService:Create(btn, TweenInfo.new(0.08), {Size = orig})
        t1:Play(); t1.Completed:Wait(); t2:Play()
    end)
end

local function makeSmoothDraggable(frame, speed)
    speed = speed or 0.2
    local dragging, dragInput, dragStart, startPos
    local function update(input)
        local delta = input.Position - dragStart
        local goal = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        TweenService:Create(frame, TweenInfo.new(speed, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Position = goal}):Play()
    end
    frame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    frame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then dragInput = input end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then update(input) end
    end)
end

local function CreateButton(parent, name, callback)
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = UDim2.new(1, -10, 0, 30)
    buttonFrame.BackgroundTransparency = 1
    buttonFrame.Parent = parent

    local button = Instance.new("TextButton")
    button.Size = UDim2.new(0.7, -5, 1, 0)
    button.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    button.BackgroundTransparency = 0.2
    button.TextColor3 = Color3.fromRGB(0, 0, 0)
    button.TextSize = 14
    button.Font = Enum.Font.Gotham
    button.Text = name
    button.Parent = buttonFrame
    Instance.new("UICorner", button).CornerRadius = UDim.new(0, 6)
    attachButtonEffects(button, 3)
    button.MouseButton1Click:Connect(callback)

    local keyBox = Instance.new("TextBox")
    keyBox.Size = UDim2.new(0.3, 0, 1, 0)
    keyBox.Position = UDim2.new(0.7, 5, 0, 0)
    keyBox.BackgroundColor3 = Color3.fromRGB(230, 230, 230)
    keyBox.PlaceholderText = "Key"
    keyBox.Text = ""
    keyBox.TextColor3 = Color3.fromRGB(0, 0, 0)
    keyBox.TextSize = 14
    keyBox.Font = Enum.Font.Gotham
    keyBox.ClearTextOnFocus = false
    keyBox.Parent = buttonFrame
    Instance.new("UICorner", keyBox).CornerRadius = UDim.new(0, 6)

    keyBox:GetPropertyChangedSignal("Text"):Connect(function()
        local text = keyBox.Text:upper()
        if text == "" then
            for k, v in pairs(Keybinds) do
                if v == callback then
                    Keybinds[k] = nil
                end
            end
        elseif text == "BUTTON" then
            local screenGui = Instance.new("ScreenGui")
            screenGui.IgnoreGuiInset = true
            screenGui.Parent = game:GetService("CoreGui")

            local screenBtn = Instance.new("TextButton")
            screenBtn.Size = UDim2.new(0, 70, 0, 30)
            screenBtn.Position = UDim2.new(0, 100, 0, 300)
            screenBtn.BackgroundColor3 = Color3.fromRGB(200, 200, 200)
            screenBtn.Text = name
            screenBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
            screenBtn.TextSize = 10
            screenBtn.Font = Enum.Font.GothamBold
            screenBtn.Parent = screenGui
            Instance.new("UICorner", screenBtn).CornerRadius = UDim.new(0, 6)
            makeSmoothDraggable(screenBtn, 0.18)
            attachButtonEffects(screenBtn, 3)
            screenBtn.MouseButton1Click:Connect(callback)
        else
            if Enum.KeyCode[text] then
                Keybinds[text] = nil
                Keybinds[text] = callback
            end
        end
    end)

    return button
end

--// Toggle Button
local ToggleButton = Instance.new("TextButton")
ToggleButton.Size = UDim2.new(0, 45, 0, 45)
ToggleButton.Position = UDim2.new(0, 15, 0, 250)
ToggleButton.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
ToggleButton.Text = "≡"
ToggleButton.TextColor3 = Color3.fromRGB(0, 0, 0)
ToggleButton.TextSize = 20
ToggleButton.Font = Enum.Font.GothamBold
ToggleButton.Parent = gui
Instance.new("UICorner", ToggleButton).CornerRadius = UDim.new(0, 10)
attachButtonEffects(ToggleButton, 5)
makeSmoothDraggable(ToggleButton, 0.18)

--// MainFrame
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 400, 0, 300)
MainFrame.Position = UDim2.new(0.08, 0, 0.2, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
MainFrame.Visible = false
MainFrame.Parent = gui
Instance.new("UICorner", MainFrame).CornerRadius = UDim.new(0, 12)
makeSmoothDraggable(MainFrame, 0.2)

-- Shadow
local shadow = Instance.new("ImageLabel", MainFrame)
shadow.Size = UDim2.new(1, 30, 1, 30)
shadow.Position = UDim2.new(0, -15, 0, -15)
shadow.Image = "rbxassetid://1316045217"
shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
shadow.ImageTransparency = 0.4
shadow.ScaleType = Enum.ScaleType.Slice
shadow.SliceCenter = Rect.new(10, 10, 118, 118)
shadow.ZIndex = -1
shadow.BackgroundTransparency = 1

-- Title
local Title = Instance.new("TextLabel", MainFrame)
Title.Size = UDim2.new(1, -10, 0, 35)
Title.Position = UDim2.new(0, 5, 0, 5)
Title.Text = "DhuyxDtuyen"
Title.Font = Enum.Font.GothamBold
Title.TextSize = 18
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1

-- Ping/FPS/Clock
local PingClock = Instance.new("TextLabel")
PingClock.Size = UDim2.new(0, 200, 0, 25)
PingClock.Position = UDim2.new(0, 5, 0, 35)
PingClock.BackgroundTransparency = 1
PingClock.TextColor3 = Color3.fromRGB(200, 200, 200)
PingClock.Font = Enum.Font.Gotham
PingClock.TextSize = 12
PingClock.Parent = MainFrame

task.spawn(function()
    local lastDt = 1/60
    RunService.RenderStepped:Connect(function(dt) lastDt = dt end)
    while task.wait(0.5) do
        local ping =  math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        local fps = math.clamp(math.floor(1 / (lastDt > 0 and lastDt or 1/240)), 1, 999)
        local timeStr = os.date("%H:%M")
        PingClock.Text = string.format("Ping: %d ms | FPS: %d | %s", ping, fps, timeStr)
    end
end)

--// Tabs
local TabHolder = Instance.new("Frame", MainFrame)
TabHolder.Size = UDim2.new(1, -10, 0, 30)
TabHolder.Position = UDim2.new(0, 5, 0, 65)
TabHolder.BackgroundTransparency = 1
local TabLayout = Instance.new("UIListLayout", TabHolder)
TabLayout.FillDirection = Enum.FillDirection.Horizontal
TabLayout.Padding = UDim.new(0, 5)

local function createTab(name)
    local btn = Instance.new("TextButton", TabHolder)
    btn.Size = UDim2.new(0, 90, 1, 0) -- Adjusted for 4 tabs
    btn.Text = name
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    btn.TextColor3 = Color3.fromRGB(0, 0, 0)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)
    attachButtonEffects(btn, 3)
    return btn
end

local Tab1Btn = createTab("Da Hood")
local Tab2Btn = createTab("Universal")
local Tab3Btn = createTab("Scripts")
local Tab5Btn = createTab("Info")

--// Pages
local Pages = Instance.new("Frame", MainFrame)
Pages.Size = UDim2.new(1, -10, 1, -105)
Pages.Position = UDim2.new(0, 5, 0, 100)
Pages.BackgroundTransparency = 1
Pages.ClipsDescendants = true

local Page1 = Instance.new("Frame", Pages) -- Da Hood
Page1.Size = UDim2.new(1, 0, 1, 0)
Page1.BackgroundTransparency = 1

local Page2 = Instance.new("Frame", Pages) -- Universal
Page2.Size = UDim2.new(1, 0, 1, 0)
Page2.BackgroundTransparency = 1
Page2.Visible = false

local Page3 = Instance.new("Frame", Pages) -- Scripts
Page3.Size = UDim2.new(1, 0, 1, 0)
Page3.BackgroundTransparency = 1
Page3.Visible = false

local Page5 = Instance.new("Frame", Pages) -- Info
Page5.Size = UDim2.new(1, 0, 1, 0)
Page5.BackgroundTransparency = 1
Page5.Visible = false

local function switchPage(page)
    Page1.Visible = (page == Page1)
    Page2.Visible = (page == Page2)
    Page3.Visible = (page == Page3)
    Page5.Visible = (page == Page5)
end

Tab1Btn.MouseButton1Click:Connect(function() switchPage(Page1) end)
Tab2Btn.MouseButton1Click:Connect(function() switchPage(Page2) end)
Tab3Btn.MouseButton1Click:Connect(function() switchPage(Page3) end)
Tab5Btn.MouseButton1Click:Connect(function() switchPage(Page5) end)

--// Page 1 (Da Hood)
local ButtonFrame1 = Instance.new("ScrollingFrame", Page1)
ButtonFrame1.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame1.Position = UDim2.new(0, 5, 0, 10)
ButtonFrame1.BackgroundTransparency = 1
ButtonFrame1.ScrollBarThickness = 4
ButtonFrame1.CanvasSize = UDim2.new(0, 0, 0, 0)

local ButtonLayout1 = Instance.new("UIListLayout", ButtonFrame1)
ButtonLayout1.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout1.Padding = UDim.new(0, 6)
ButtonLayout1:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame1.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout1.AbsoluteContentSize.Y)
end)

local PlayerListFrame = Instance.new("ScrollingFrame", Page1)
PlayerListFrame.Size = UDim2.new(0.5, -5, 1, -20)
PlayerListFrame.Position = UDim2.new(0.5, 0, 0, 10)
PlayerListFrame.BackgroundTransparency = 1
PlayerListFrame.ScrollBarThickness = 4
PlayerListFrame.CanvasSize = UDim2.new(0, 0, 0, 0)

local UIListLayout = Instance.new("UIListLayout", PlayerListFrame)
UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
UIListLayout.Padding = UDim.new(0, 4)
UIListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    PlayerListFrame.CanvasSize = UDim2.new(0, 0, 0, UIListLayout.AbsoluteContentSize.Y)
end)

-- Populate PlayerList
local function updatePlayerList()
    for _, child in ipairs(PlayerListFrame:GetChildren()) do
        if child:IsA("Frame") then
            child:Destroy()
        end
    end

    for _, player in ipairs(Players:GetPlayers()) do
        local playerFrame = Instance.new("Frame", PlayerListFrame)
        playerFrame.Size = UDim2.new(1, -10, 0, 30)
        playerFrame.BackgroundTransparency = 0.2
        playerFrame.BackgroundColor3 = Color3.fromRGB(230, 230, 230)

        local playerLabel = Instance.new("TextLabel", playerFrame)
        playerLabel.Size = UDim2.new(1, -5, 1, 0)
        playerLabel.BackgroundTransparency = 1
        playerLabel.Text = player.DisplayName .. " (@" .. player.Name .. ")"
        playerLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
        playerLabel.TextSize = 14
        playerLabel.Font = Enum.Font.Gotham
        playerLabel.TextXAlignment = Enum.TextXAlignment.Left

        Instance.new("UICorner", playerFrame).CornerRadius = UDim.new(0, 6)
    end
end

Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)
updatePlayerList()

--// Page 2 (Universal)
local ButtonFrame2Left = Instance.new("ScrollingFrame", Page2)
ButtonFrame2Left.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame2Left.Position = UDim2.new(0, 5, 0, 10)
ButtonFrame2Left.BackgroundTransparency = 1
ButtonFrame2Left.ScrollBarThickness = 4
ButtonFrame2Left.CanvasSize = UDim2.new(0, 0, 0, 0)

local ButtonLayout2Left = Instance.new("UIListLayout", ButtonFrame2Left)
ButtonLayout2Left.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout2Left.Padding = UDim.new(0, 6)
ButtonLayout2Left:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame2Left.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout2Left.AbsoluteContentSize.Y)
end)

local ButtonFrame2Right = Instance.new("ScrollingFrame", Page2)
ButtonFrame2Right.Size = UDim2.new(0.5, -5, 1, -20)
ButtonFrame2Right.Position = UDim2.new(0.5, 0, 0, 10)
ButtonFrame2Right.BackgroundTransparency = 1
ButtonFrame2Right.ScrollBarThickness = 4
ButtonFrame2Right.CanvasSize = UDim2.new(0, 0, 0, 0)

local ButtonLayout2Right = Instance.new("UIListLayout", ButtonFrame2Right)
ButtonLayout2Right.SortOrder = Enum.SortOrder.LayoutOrder
ButtonLayout2Right.Padding = UDim.new(0, 6)
ButtonLayout2Right:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ButtonFrame2Right.CanvasSize = UDim2.new(0, 0, 0, ButtonLayout2Right.AbsoluteContentSize.Y)
end)

--// Page 3 (Scripts)
local ScriptHubScroll = Instance.new("ScrollingFrame", Page3)
ScriptHubScroll.Size = UDim2.new(1, -10, 1, -30) -- Extended height for more space
ScriptHubScroll.Position = UDim2.new(0, 5, 0, 5)
ScriptHubScroll.BackgroundTransparency = 1
ScriptHubScroll.ScrollBarThickness = 6
ScriptHubScroll.ScrollingDirection = Enum.ScrollingDirection.Y
ScriptHubScroll.CanvasSize = UDim2.new(0, 0, 0, 0)

local ScriptListLayout = Instance.new("UIListLayout", ScriptHubScroll)
ScriptListLayout.SortOrder = Enum.SortOrder.LayoutOrder
ScriptListLayout.Padding = UDim.new(0, 6)
ScriptListLayout.FillDirection = Enum.FillDirection.Vertical
ScriptListLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
    ScriptHubScroll.CanvasSize = UDim2.new(0, 0, 0, ScriptListLayout.AbsoluteContentSize.Y)
end)

local function CreateScriptItem(name, url)
    local itemFrame = Instance.new("Frame", ScriptHubScroll)
    itemFrame.Size = UDim2.new(1, 0, 0, 35)
    itemFrame.BackgroundTransparency = 0.2
    itemFrame.BackgroundColor3 = Color3.fromRGB(230, 230, 230)

    local nameLabel = Instance.new("TextLabel", itemFrame)
    nameLabel.Size = UDim2.new(0.7, 0, 1, 0)
    nameLabel.Position = UDim2.new(0, 5, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = name
    nameLabel.TextColor3 = Color3.fromRGB(0, 0, 0)
    nameLabel.TextSize = 16
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextXAlignment = Enum.TextXAlignment.Left

    local runBtn = Instance.new("TextButton", itemFrame)
    runBtn.Size = UDim2.new(0.3, -10, 1, -4)
    runBtn.Position = UDim2.new(0.7, 5, 0, 2)
    runBtn.BackgroundColor3 = Color3.fromRGB(180, 180, 180)
    runBtn.Text = "Run"
    runBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
    runBtn.TextSize = 16
    runBtn.Font = Enum.Font.GothamBold
    Instance.new("UICorner", runBtn).CornerRadius = UDim.new(0, 6)
    attachButtonEffects(runBtn, 3)
    runBtn.MouseButton1Click:Connect(function()
        loadstring(game:HttpGet(url))()
    end)

    Instance.new("UICorner", itemFrame).CornerRadius = UDim.new(0, 6)
    return itemFrame
end

CreateScriptItem("Evade", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/evade")
CreateScriptItem("Murder Mystery 2", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/mm2")
CreateScriptItem("Blade Ball", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/Bladeball")
CreateScriptItem("Doors", "https://raw.githubusercontent.com/DarkDoorsKing/Project/main/Doors.lua")
CreateScriptItem("Emote", "https://raw.githubusercontent.com/dadada-rgb/VhuyHub/refs/heads/main/emote")
CreateScriptItem("Infinite Yield", "https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source")
CreateScriptItem("Dex", "https://raw.githubusercontent.com/infyiff/backup/main/dex.lua")

--// Page 5 (Info)
local Avatar = Instance.new("ImageLabel", Page5)
Avatar.Size = UDim2.new(0, 80, 0, 80)
Avatar.Position = UDim2.new(0, 10, 0, 10)
Avatar.BackgroundTransparency = 1
Avatar.Image = "rbxthumb://type=AvatarHeadShot&id="..LocalPlayer.UserId.."&w=150&h=150"

local InfoPanel = Instance.new("Frame", Page5)
InfoPanel.Position = UDim2.new(0, 100, 0, 10)
InfoPanel.Size = UDim2.new(1, -110, 1, -20)
InfoPanel.BackgroundTransparency = 1
InfoPanel.ClipsDescendants = true

local InfoLayout = Instance.new("UIListLayout", InfoPanel)
InfoLayout.Padding = UDim.new(0, 6)
InfoLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
InfoLayout.VerticalAlignment = Enum.VerticalAlignment.Top

local function mkLine()
    local l = Instance.new("TextLabel")
    l.Size = UDim2.new(1, -10, 0, 22)
    l.BackgroundTransparency = 1
    l.Font = Enum.Font.Gotham
    l.TextSize = 14
    l.TextColor3 = Color3.fromRGB(200, 200, 200)
    l.TextXAlignment = Enum.TextXAlignment.Left
    l.TextWrapped = false
    l.ClipsDescendants = true
    l.Parent = InfoPanel
    return l
end

local lineDisplay = mkLine()
local lineUser = mkLine()
local lineFPS = mkLine()
local lineTime = mkLine()
local lineCountry = mkLine()
local lineFriends = mkLine()

lineDisplay.Text = "Display Name : "..LocalPlayer.DisplayName
lineUser.Text = "Username     : @"..LocalPlayer.Name

task.spawn(function()
    local c = "Unknown"
    pcall(function()
        c = LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer) or "Unknown"
    end)
    lineCountry.Text = "Country      : "..c
end)

task.spawn(function()
    local ok, list = pcall(function() return Players:GetFriendsOnline() end)
    local count = (ok and type(list)=="table") and #list or 0
    lineFriends.Text = "Friends Online: "..count
end)

task.spawn(function()
    local lastDt = 1/60
    RunService.RenderStepped:Connect(function(dt) lastDt = dt end)
    while task.wait(0.5) do
        local fps = math.clamp(math.floor(1 / (lastDt > 0 and lastDt or 1/240)), 1, 999)
        lineFPS.Text = "FPS          : "..fps
        lineTime.Text = "Time         : "..os.date("%H:%M")
    end
end)

--// Toggle open/close
ToggleButton.MouseButton1Click:Connect(function()
    MainFrame.Visible = not MainFrame.Visible
end)

--// Keybinds
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    local key = input.KeyCode.Name:upper()
    if Keybinds[key] then
        Keybinds[key]()
    end
end)

function sendNotification(title, text, duration)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title or "DhuyxDtuyen",
            Text = text or "",
            Duration = duration or 3
        })
    end)
end

local autoSelect = false
local tbEnabled = true
local fovRadius = 20
local Player = nil
local camera = Workspace.CurrentCamera
local clickTpTool = nil
local savedWaypoint = nil
local noclipConnection = nil
local Keybinds = {} 

-- Biến lưu trạng thái Lighting cũ cho Fullbright
local oldLighting = {
    Brightness = Lighting.Brightness,
    GlobalShadows = Lighting.GlobalShadows,
    FogEnd = Lighting.FogEnd,
    Ambient = Lighting.Ambient,
    OutdoorAmbient = Lighting.OutdoorAmbient,
    ClockTime = Lighting.ClockTime
}

-- Tạo hiệu ứng mờ nền
local blur = Instance.new("BlurEffect")
blur.Size = 20
blur.Parent = Lighting

-- Tạo GUI intro
local introGui = Instance.new("ScreenGui")
introGui.Name = "VhuyIntroGui"
introGui.IgnoreGuiInset = true
introGui.ResetOnSpawn = false
introGui.DisplayOrder = 99999
introGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local bg = Instance.new("Frame")
bg.Size = UDim2.new(1, 0, 1, 0)
bg.BackgroundColor3 = Color3.new(0, 0, 0)
bg.BackgroundTransparency = 1
bg.Parent = introGui

local title = Instance.new("TextLabel")
title.AnchorPoint = Vector2.new(0.5, 0.5)
title.Position = UDim2.new(0.5, 0, 0.5, 0)
title.Size = UDim2.new(0, 400, 0, 120)
title.Text = "DhuyxDtuyen"
title.Font = Enum.Font.GothamBlack
title.TextColor3 = Color3.fromRGB(55, 55, 55)
title.TextScaled = true
title.TextTransparency = 1
title.BackgroundTransparency = 1
title.Parent = introGui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 12)
corner.Parent = title

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(55, 55, 55)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(230, 230, 230))
}
gradient.Rotation = 45
gradient.Parent = title

-- Hiệu ứng fade in
TweenService:Create(title, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {TextTransparency = 0}):Play()
TweenService:Create(bg, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {BackgroundTransparency = 0.4}):Play()

-- Hiệu ứng fade out
task.delay(4, function()
    TweenService:Create(title, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {TextTransparency = 1}):Play()
    TweenService:Create(bg, TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
    task.delay(1.5, function()
        introGui:Destroy()
        blur:Destroy()
    end)
end)

-- Nút cho trang 1
espButton = CreateButton(ButtonFrame1, "ESP: OFF", function()
    Config.ESPEnabled = not Config.ESPEnabled
    espButton.Text = "ESP: " .. (Config.ESPEnabled and "ON" or "OFF")
    sendNotification("ESP", Config.ESPEnabled and "ON" or "OFF")
end)

speedButton = CreateButton(ButtonFrame1, "Speed: OFF", function()
    Config.SpeedEnabled = not Config.SpeedEnabled
    speedButton.Text = "Speed: " .. (Config.SpeedEnabled and "ON" or "OFF")
    sendNotification("SPEED", Config.SpeedEnabled and "ON" or "OFF")
end)

flyButton = CreateButton(ButtonFrame1, "Fly: OFF", function()
    Config.FlyEnabled = not Config.FlyEnabled
    flyButton.Text = "Fly: " .. (Config.FlyEnabled and "ON" or "OFF")
    sendNotification("FLY", Config.FlyEnabled and "ON" or "OFF")
end)

aimbotButton = CreateButton(ButtonFrame1, "Aimlock: OFF", function()
    Config.AimbotEnabled = not Config.AimbotEnabled
    aimbotButton.Text = "Aimlock: " .. (Config.AimbotEnabled and "ON" or "OFF")
    sendNotification("AIMLOCK", Config.AimbotEnabled and "ON" or "OFF")
end)

-- Hàm GetPing
local function GetPing()
    local stats = game:GetService("Stats"):FindFirstChild("Network")
    local data = stats and stats:FindFirstChild("DataPing")
    return data and math.clamp(data:GetValue(), 10, 300) or 40
end

local function CalculateVIPPrediction(part, ping)
    if not part or not part:IsA("BasePart") then return nil end
    local velocity = part.Velocity
    local origin = Camera.CFrame.Position
    local distance = (part.Position - origin).Magnitude
    local delay = (ping or GetPing()) / 1000
    local distanceFactor = math.clamp(distance / 100, 1, 3)
    return part.Position + velocity * delay * distanceFactor
end


-- Loop cập nhật Prediction
task.spawn(function()
    while task.wait(0.2) do
        local ping = GetPing()
        if Config.AutoPredictionEnabled then
            Config.Prediction = CalculateVIPPrediction(ping)
        else
            local cp = Config.CustomPing or ping
            Config.Prediction = CalculateVIPPrediction(cp)
        end
    end
end)

-- Ô nhập Ping (bỏ qua khi AutoPrediction bật)
local predictionBox = Instance.new("TextBox")
predictionBox.Size = UDim2.new(1, -10, 0, 25)
predictionBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
predictionBox.BackgroundTransparency = 0.2
predictionBox.TextColor3 = Color3.fromRGB(0, 0, 0)
predictionBox.TextSize = 14
predictionBox.Font = Enum.Font.Gotham
predictionBox.PlaceholderText = "Nhập Ping"
predictionBox.Text = tostring(Config.CustomPing or 40)
predictionBox.ClearTextOnFocus = false
predictionBox.Parent = ButtonFrame1
Instance.new("UICorner", predictionBox).CornerRadius = UDim.new(0, 6)

predictionBox:GetPropertyChangedSignal("Text"):Connect(function()
    if Config.AutoPredictionEnabled then return end -- khi auto bật thì bỏ qua input
    local num = tonumber(predictionBox.Text)
    if num then
        Config.CustomPing = math.clamp(num, 10, 300)
    end
end)

autoPredictionButton = CreateButton(ButtonFrame1, "Auto Prediction: OFF", function()
    Config.AutoPredictionEnabled = not Config.AutoPredictionEnabled
    autoPredictionButton.Text = "Auto Prediction: " .. (Config.AutoPredictionEnabled and "ON" or "OFF")
    sendNotification("Auto Prediction", Config.AutoPredictionEnabled and "ON" or "OFF")
end)

macroLegitButton = CreateButton(ButtonFrame1, "Macro Legit: " .. (Config.MacroLegitEnabled and "ON" or "OFF"), function()
    Config.MacroLegitEnabled = not Config.MacroLegitEnabled
    macroLegitButton.Text = "Macro Legit: " .. (Config.MacroLegitEnabled and "ON" or "OFF")
    sendNotification("Macro Legit", Config.MacroLegitEnabled and "Enabled" or "Disabled")

    if Config.MacroLegitEnabled then
        task.spawn(function()
            repeat
                game:GetService("RunService").Heartbeat:Wait()
                game:GetService("VirtualInputManager"):SendMouseWheelEvent(0.1, 0.1, true, game)
                game:GetService("RunService").Heartbeat:Wait()
                game:GetService("VirtualInputManager"):SendMouseWheelEvent(0.1, 0.1, false, game)
                game:GetService("RunService").Heartbeat:Wait()
            until not Config.MacroLegitEnabled
        end)
    end
end)

-- Danh sách mode AntiLock
local antiLockModes = {
    "OFF",
    "Behind",
    "Down",
    "Forward",
    "Left",
    "One",
    "Right",
    "Up",
    "Zero",
}

Config.AntiLockType = "OFF"
Config.AntiLockEnabled = false
local modeIndex = 1
local antiLockButton

antiLockButton = CreateButton(ButtonFrame1, "AntiLock: OFF", function()
    -- tăng mode
    modeIndex = modeIndex + 1
    if modeIndex > #antiLockModes then
        modeIndex = 1
    end

    local mode = antiLockModes[modeIndex]
    if mode == "OFF" then
        Config.AntiLockEnabled = false
    else
        Config.AntiLockEnabled = true
        Config.AntiLockType = mode
    end

    antiLockButton.Text = "AntiLock: " .. mode
    sendNotification("AntiLock", "Mode: " .. mode)
end)

-- ======= LOGIC ANTILOCK =======
if _G.__vhuyhub_antilock_conn then
    _G.__vhuyhub_antilock_conn:Disconnect()
end

_G.__vhuyhub_antilock_conn = RunService.Heartbeat:Connect(function()
    if not Config.AntiLockEnabled then return end

    local char = LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local dir = Vector3.new(0, 0, -1) -- default Behind
    local t = Config.AntiLockType
    if     t == "Behind"  then dir = Vector3.new(0,  0, -1)
    elseif t == "Down"    then dir = Vector3.new(0, -1,  0)
    elseif t == "Forward" then dir = Vector3.new(0,  0,  1)
    elseif t == "Left"    then dir = Vector3.new(-1, 0,  0)
    elseif t == "One"     then dir = Vector3.new(1,  1,  1)
    elseif t == "Right"   then dir = Vector3.new(1,  0,  0)
    elseif t == "Up"      then dir = Vector3.new(0,  1,  0)
    elseif t == "Zero"    then dir = Vector3.new(0,  0,  0)
    end

    local oldVel = hrp.Velocity
    hrp.Velocity = dir * (2^16)
    RunService.RenderStepped:Wait()
    if hrp and hrp.Parent then
        hrp.Velocity = oldVel
    end
end)

-- ==== UTILS ====
local function getMyHumanoid()
    local char = LocalPlayer.Character
    if not char then return nil,nil,nil end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    return char, hum, hrp
end

local function getClosestSelected()
    local _, _, myHRP = getMyHumanoid()
    if not myHRP then return end
    
    local myPos, closest, minDist = myHRP.Position, nil, math.huge
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local hrp = Players:FindFirstChild(name)
                and Players[name].Character
                and Players[name].Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (myPos - hrp.Position).Magnitude
                if dist < minDist then
                    closest, minDist = Players[name], dist
                end
            end
        end
    end
    return closest
end

local lastTargetName, lastNotify = nil, 0

-- LOOK AT chỉ hoạt động khi Csync bật
RunService.RenderStepped:Connect(function()
    if not (Config.CsyncOrbitEnabled or Config.CsyncRandomEnabled) then
        Config.LookAtEnabled = false
        return
    end
    
    Config.LookAtEnabled = true
    local char, hum, hrp = getMyHumanoid()
    if not (hum and hrp) then return end
    hum.AutoRotate = false

    local targetPlr = getClosestSelected()
    if not targetPlr then return end

    local thrp = targetPlr.Character and targetPlr.Character:FindFirstChild("HumanoidRootPart")
    if not thrp then return end

    local myPos = hrp.Position
    local tPos = thrp.Position
    local facePos = Vector3.new(tPos.X, myPos.Y, tPos.Z)

    hrp.CFrame = hrp.CFrame:Lerp(CFrame.lookAt(myPos, facePos), 0.35)
end)

-- Khi chết → tự reset AutoRotate
LocalPlayer.CharacterAdded:Connect(function()
    task.defer(function()
        local _, hum = getMyHumanoid()
        if hum then hum.AutoRotate = true end
    end)
end)

triggerBotButton = CreateButton(ButtonFrame1, "TriggerBot: " .. (tbEnabled and "ON" or "OFF"), function()
    tbEnabled = not tbEnabled
    triggerBotButton.Text = "TriggerBot: " .. (tbEnabled and "ON" or "OFF")
    sendNotification("TRIGGERBOT", tbEnabled and "ON" or "OFF")
end)

-- Resolver Button (Page 2, Left Side)
local resolverEnabled = false

resolverButton = CreateButton(ButtonFrame1, "Resolver: OFF", function()
    resolverEnabled = not resolverEnabled
    resolverButton.Text = "Resolver: " .. (resolverEnabled and "ON" or "OFF")
    sendNotification("Resolver", resolverEnabled and "Enabled" or "Disabled")
end)

RunService.Heartbeat:Connect(function()
    if resolverEnabled then
        for _,plr in ipairs(Players:GetPlayers()) do
            if plr ~= Players.LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                -- Reset velocity để aim không bị lệch
                plr.Character.HumanoidRootPart.Velocity = Vector3.new(0, plr.Character.HumanoidRootPart.Velocity.Y, 0)
            end
        end
    end
end)

-- Hàm tìm RemoteEvent bất kể viết hoa/thường/có dấu cách
local function getMainEvent()
    local rs = game:GetService("ReplicatedStorage")
    for _, obj in ipairs(rs:GetDescendants()) do
        if obj:IsA("RemoteEvent") and string.lower(obj.Name):gsub("%s+", "") == "mainevent" then
            return obj
        end
    end
    return nil
end

local function isAlive(plr)
    if not plr or not plr.Character then return false end
    local hum = plr.Character:FindFirstChildOfClass("Humanoid")
    if not hum or hum.Health <= 0 then
        return false
    end

    -- Check riêng cho Da Hood (BodyEffects)
    local be = plr.Character:FindFirstChild("BodyEffects")
    if be then
        local ko = be:FindFirstChild("K.O")
        local grabbed = be:FindFirstChild("Grabbed")
        if (ko and ko.Value) or (grabbed and grabbed.Value) then
            return false
        end
    end

    return true
end

local function getClosestSelected()
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local closest, minDist
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local hrp = plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
            if hrp then
                local dist = (myHRP.Position - hrp.Position).Magnitude
                if not minDist or dist < minDist then
                    closest, minDist = plr, dist
                end
            end
        end
    end
    return closest
end

local function getNextTarget(currentTarget)
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end
    local candidates = {}
    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr ~= currentTarget and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                table.insert(candidates, plr)
            end
        end
    end
    table.sort(candidates, function(a, b)
        local ha = a.Character and a.Character:FindFirstChild("HumanoidRootPart")
        local hb = b.Character and b.Character:FindFirstChild("HumanoidRootPart")
        if not ha or not hb then return false end
        return (myHRP.Position - ha.Position).Magnitude < (myHRP.Position - hb.Position).Magnitude
    end)
    return candidates[1]
end

-- ========================
-- Nút GUI
-- ========================
csyncRandomButton = CreateButton(ButtonFrame1, "Csync Random: " .. (Config.CsyncRandomEnabled and "ON" or "OFF"), function()
    Config.CsyncRandomEnabled = not Config.CsyncRandomEnabled
    csyncRandomButton.Text = "Csync Random: " .. (Config.CsyncRandomEnabled and "ON" or "OFF")
    sendNotification("Csync Random", Config.CsyncRandomEnabled and "Enabled" or "Disabled")
end)

csyncOrbitButton = CreateButton(ButtonFrame1, "Csync Orbit: " .. (Config.CsyncOrbitEnabled and "ON" or "OFF"), function()
    Config.CsyncOrbitEnabled = not Config.CsyncOrbitEnabled
    csyncOrbitButton.Text = "Csync Orbit: " .. (Config.CsyncOrbitEnabled and "ON" or "OFF")
    sendNotification("Csync Orbit", Config.CsyncOrbitEnabled and "Enabled" or "Disabled")
end)

-- Frame nhập Radius, Height, Speed
local boxFrame = Instance.new("Frame")
boxFrame.Size = UDim2.new(1, 0, 0, 40)
boxFrame.BackgroundTransparency = 1
boxFrame.Parent = ButtonFrame1

local function createLabeledBox(parent, labelText, default, onChange, pos)
    local container = Instance.new("Frame")
    container.Size = UDim2.new(1/3 - 0.02, 0, 1, 0)
    container.Position = pos
    container.BackgroundTransparency = 1
    container.Parent = parent

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 0, 10)
    label.BackgroundTransparency = 1
    label.Text = labelText
    label.TextSize = 10
    label.TextColor3 = Color3.fromRGB(180, 180, 180)
    label.Font = Enum.Font.Gotham
    label.Parent = container

    local tb = Instance.new("TextBox")
    tb.Size = UDim2.new(1, 0, 0, 20)
    tb.Position = UDim2.new(0, 0, 0, 12)
    tb.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    tb.TextColor3 = Color3.new(1, 1, 1)
    tb.Text = tostring(default)
    tb.PlaceholderText = labelText
    tb.ClearTextOnFocus = false
    tb.Font = Enum.Font.GothamBold
    tb.TextSize = 12
    tb.Parent = container
    Instance.new("UICorner", tb).CornerRadius = UDim.new(0, 4)

    tb.FocusLost:Connect(function()
        local num = tonumber(tb.Text)
        if num then
            onChange(num)
        else
            tb.Text = tostring(default)
        end
    end)
end

createLabeledBox(boxFrame, "Radius", Config.CsyncRadius, function(v) Config.CsyncRadius = v end, UDim2.new(0, 0, 0, 0))
createLabeledBox(boxFrame, "Height", Config.CsyncHeight, function(v) Config.CsyncHeight = v end, UDim2.new(1/3, 0, 0, 0))
createLabeledBox(boxFrame, "Speed",  Config.CsyncSpeed,  function(v) Config.CsyncSpeed  = v end, UDim2.new(2/3, 0, 0, 0))

local currentTarget = nil
local csyncPaused = false

if _G.VHUB_CSYNC_LOOP then _G.VHUB_CSYNC_LOOP:Disconnect() end
_G.VHUB_CSYNC_LOOP = RunService.Heartbeat:Connect(function()
    -- Nếu chưa có target hoặc target không tồn tại → tìm mới
    if not currentTarget or not currentTarget.Parent then
        currentTarget = getClosestSelected()
    end

    -- Nếu đang pause thì thử tìm lại target để resume
    if csyncPaused then
        if currentTarget then
            csyncPaused = false
        else
            return
        end
    end

    -- Nếu vẫn không có target thì dừng (pause)
    if not currentTarget then
        csyncPaused = true
        return
    end

    -- Nếu target bị KO → đổi target hoặc pause
    if isAlive(currentTarget) then
        local nextTarget = getNextTarget(currentTarget)
        if nextTarget then
            currentTarget = nextTarget
        else
            csyncPaused = true
            return
        end
    end

    -- Thực hiện Csync nếu không pause
    if not csyncPaused then
        local hrp = currentTarget.Character and currentTarget.Character:FindFirstChild("HumanoidRootPart")
        local myHRP = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp or not myHRP then return end

        if Config.CsyncOrbitEnabled then
            local t = tick() * Config.CsyncSpeed
            local pos = hrp.Position + Vector3.new(
                math.cos(t) * Config.CsyncRadius,
                Config.CsyncHeight,
                math.sin(t) * Config.CsyncRadius
            )
            myHRP.CFrame = CFrame.new(pos, hrp.Position)
        elseif Config.CsyncRandomEnabled then
            local offset = Vector3.new(
                math.random(-Config.CsyncRadius, Config.CsyncRadius),
                Config.CsyncHeight,
                math.random(-Config.CsyncRadius, Config.CsyncRadius)
            )
            myHRP.CFrame = CFrame.new(hrp.Position + offset, hrp.Position)
        end
    end
end)

-- ========================
-- Khi chết → tắt Csync + Look At
-- ========================
LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if Config.CsyncOrbitEnabled or Config.CsyncRandomEnabled then
        Config.CsyncOrbitEnabled = false
        Config.CsyncRandomEnabled = false
        csyncOrbitButton.Text = "Csync Orbit: OFF"
        csyncRandomButton.Text = "Csync Random: OFF"
        sendNotification("Csync", "Đã tắt vì bạn chết")
    end
end)

local customFovEnabled = false
local defaultFov = Workspace.CurrentCamera.FieldOfView

-- Ô nhập giá trị FOV (mặc định 120)
local fovBox = Instance.new("TextBox")
fovBox.Size = UDim2.new(1, -10, 0, 25)
fovBox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
fovBox.BackgroundTransparency = 0.2
fovBox.TextColor3 = Color3.fromRGB(0, 0, 0)
fovBox.TextSize = 14
fovBox.Font = Enum.Font.Gotham
fovBox.Text = "120" -- mặc định giá trị 120
fovBox.PlaceholderText = "Nhập FOV (40-120)"
fovBox.ClearTextOnFocus = false
fovBox.Parent = ButtonFrame2Left
Instance.new("UICorner", fovBox).CornerRadius = UDim.new(0, 6)

-- Nút bật tắt Custom FOV
customFovButton = CreateButton(ButtonFrame2Left, "Custom FOV: OFF", function()
    customFovEnabled = not customFovEnabled
    customFovButton.Text = "Custom FOV: " .. (customFovEnabled and "ON" or "OFF")

    if customFovEnabled then
        local num = tonumber(fovBox.Text)
        if num and num >= 40 and num <= 120 then
            Workspace.CurrentCamera.FieldOfView = num
            sendNotification("Custom FOV", "Đã đặt FOV thành " .. num)
        else
            fovBox.Text = "120"
            Workspace.CurrentCamera.FieldOfView = 120
            sendNotification("Custom FOV", "Đã đặt FOV mặc định 120")
        end
    else
        Workspace.CurrentCamera.FieldOfView = defaultFov
        sendNotification("Custom FOV", "Đã trả về FOV mặc định " .. defaultFov)
    end
end)

-- Nếu người dùng thay đổi giá trị trong ô khi đang bật Custom FOV
fovBox:GetPropertyChangedSignal("Text"):Connect(function()
    if customFovEnabled then
        local num = tonumber(fovBox.Text)
        if num and num >= 40 and num <= 120 then
            Workspace.CurrentCamera.FieldOfView = num
            sendNotification("Custom FOV", "Đã đặt FOV thành " .. num)
        end
    end
end)
-- ============ /CUSTOM FOV ============

local oldMinZoom, oldMaxZoom, oldMode = nil, nil, nil

unlock3rdButton = CreateButton(ButtonFrame2Left, "Unlock 3rd: OFF", function()
    Config.Unlock3rdEnabled = not Config.Unlock3rdEnabled

    if Config.Unlock3rdEnabled then
        -- Lưu lại config camera cũ
        oldMinZoom = LocalPlayer.CameraMinZoomDistance
        oldMaxZoom = LocalPlayer.CameraMaxZoomDistance
        oldMode    = LocalPlayer.CameraMode

        -- Mở khóa góc nhìn thứ 3
        LocalPlayer.CameraMode = Enum.CameraMode.Classic
        LocalPlayer.CameraMinZoomDistance = 300
        LocalPlayer.CameraMaxZoomDistance = 128 -- Roblox default max zoom

        unlock3rdButton.Text = "Unlock 3rd: ON"
        sendNotification("Unlock 3rd", "Third Person Enabled")
    else
        -- Trả về camera cũ
        if oldMinZoom then LocalPlayer.CameraMinZoomDistance = oldMinZoom end
        if oldMaxZoom then LocalPlayer.CameraMaxZoomDistance = oldMaxZoom end
        if oldMode then LocalPlayer.CameraMode = oldMode end

        unlock3rdButton.Text = "Unlock 3rd: OFF"
        sendNotification("Unlock 3rd", "Third Person Disabled")
    end
end)

-- ============ HUG R6 / R15 ============
local hugEnabled = false
local hugConn
local hugButton
local Play_1, Play_2 -- giữ track để stop được cả khi OFF

local function stopHug()
    if hugConn then
        hugConn:Disconnect()
        hugConn = nil
    end
    if Play_1 then Play_1:Stop() end
    if Play_2 then Play_2:Stop() end
    hugEnabled = false
    hugButton.Text = "HugR6/R15: OFF"
end

hugButton = CreateButton(ButtonFrame2Left, "HugR6/R15: OFF", function()
    hugEnabled = not hugEnabled
    hugButton.Text = "HugR6/R15: " .. (hugEnabled and "ON" or "OFF")

    local player = game.Players.LocalPlayer
    local char = player.Character or player.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid")

    -- Reset track cũ
    if Play_1 then Play_1:Stop() end
    if Play_2 then Play_2:Stop() end
    Play_1, Play_2 = nil, nil

    -- Load Animations theo Rig
    if hum.RigType == Enum.HumanoidRigType.R6 then
        local Anim_1 = Instance.new("Animation")
        Anim_1.AnimationId = "rbxassetid://283545583"
        Play_1 = hum:LoadAnimation(Anim_1)

        local Anim_2 = Instance.new("Animation")
        Anim_2.AnimationId = "rbxassetid://225975820"
        Play_2 = hum:LoadAnimation(Anim_2)
    else
        local Anim_R15 = Instance.new("Animation")
        Anim_R15.AnimationId = "rbxassetid://118478639008343"
        Play_1 = hum:LoadAnimation(Anim_R15)
    end

    if hugEnabled then
        if Play_1 then Play_1:Play() end
        if Play_2 then Play_2:Play() end

        hugConn = game:GetService("RunService").Heartbeat:Connect(function()
            local target = getClosestSelected()
            if not (target and target.Character and target.Character:FindFirstChild("HumanoidRootPart")) then
                stopHug()
                return
            end

            local myHRP = char:FindFirstChild("HumanoidRootPart")
            local targetHRP = target.Character.HumanoidRootPart
            if myHRP and targetHRP then
                -- Vị trí trước mặt target (1 stud)
                local offsetPos = targetHRP.Position - targetHRP.CFrame.LookVector * 1

                -- Giữ đứng yên, không trôi
                pcall(function()
                    myHRP.AssemblyLinearVelocity = Vector3.zero
                    myHRP.AssemblyAngularVelocity = Vector3.zero
                end)
            end
        end)
    else
        stopHug()
    end
end)

-- Giữ HugR6 khi respawn
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    if hugEnabled then
        task.wait(0.5)
        hugButton.Text = "HugR6/R15: ON"
        -- Respawn thì stop animation cũ, sẽ play lại khi Heartbeat chạy
        if Play_1 then Play_1:Stop() end
        if Play_2 then Play_2:Stop() end
    end
end)
-- ============ /HUG R6 / R15 ============

-- Config
getgenv().CustomAnimEnabled = true

-- Đổi animation liên tục
game:GetService("RunService").Stepped:Connect(function()
    if not getgenv().CustomAnimEnabled then return end
    local char = game.Players.LocalPlayer.Character
    if char and char:FindFirstChild("Animate") then
        local anim = char.Animate
        -- Chạy
        anim.run.RunAnim.AnimationId = "http://www.roblox.com/asset/?id=616163682"
        -- Nhảy
        anim.jump.JumpAnim.AnimationId = "http://www.roblox.com/asset/?id=10921242013"
        -- Rơi
        anim.fall.FallAnim.AnimationId = "http://www.roblox.com/asset/?id=707829716"
    end
end)

-- ============ PIGGYBACK ============
local piggyEnabled = false
local piggyConn = nil
local piggyButton
local piggyAnim, piggyTrack

local function stopPiggy()
    if piggyConn then
        piggyConn:Disconnect()
        piggyConn = nil
    end
    if piggyTrack then
        piggyTrack:Stop()
        piggyTrack = nil
    end
    local myChar = LocalPlayer.Character
    local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
    if myHum then myHum.Sit = false end
    piggyEnabled = false
    piggyButton.Text = "Piggyback: OFF"
end

local function startPiggy(target)
    local myChar = LocalPlayer.Character
    local myHum  = myChar and myChar:FindFirstChildOfClass("Humanoid")
    local myHRP  = myChar and myChar:FindFirstChild("HumanoidRootPart")
    local head   = target.Character and target.Character:FindFirstChild("Head")

    if not (myHum and myHRP and head) then
        stopPiggy()
        return
    end

    -- ép nhân vật vào trạng thái ngồi
    myHum.Sit = true

    -- load animation piggyback
    piggyAnim = Instance.new("Animation")
    piggyAnim.AnimationId = "rbxassetid://115900505866868"
    piggyTrack = myHum:LoadAnimation(piggyAnim)
    piggyTrack:Play()

    piggyButton.Text = ("Piggyback: ON (%s)"):format(target.Name)
    sendNotification("Piggyback", "Đang cõng " .. target.Name)

    piggyConn = RunService.Heartbeat:Connect(function()
        local valid = piggyEnabled
            and target.Character
            and target.Character:FindFirstChild("Head")
            and myHRP
            and myHRP.Parent

        if not valid then
            stopPiggy()
            return
        end

        local tHead = target.Character.Head
        -- offset cố định: hạ xuống -0.6 và lùi ra sau 0.6 stud
        myHRP.CFrame = tHead.CFrame * CFrame.new(0, -0.6, -0.6)

        -- chống trôi
        pcall(function()
            myHRP.AssemblyLinearVelocity = Vector3.zero
            myHRP.AssemblyAngularVelocity = Vector3.zero
        end)
    end)
end

-- Nút bật / tắt
piggyButton = CreateButton(ButtonFrame2Left, "Piggyback: OFF", function()
    piggyEnabled = not piggyEnabled
    if not piggyEnabled then
        stopPiggy()
        sendNotification("Piggyback", "OFF")
        return
    end

    local target = getClosestSelected()
    if not target then
        stopPiggy()
        return
    end

    startPiggy(target)
end)

-- Giữ Piggyback khi respawn
LocalPlayer.CharacterAdded:Connect(function()
    if not piggyEnabled then return end
    task.wait(0.5)
    local target = getClosestSelected()
    if not target then
        stopPiggy()
        return
    end
    startPiggy(target)
end)
-- ============ /PIGGYBACK ============

fullbrightButton = CreateButton(ButtonFrame2Left, "Fullbright: OFF", function()
    Config.FullbrightEnabled = not Config.FullbrightEnabled
    if Config.FullbrightEnabled then
        Lighting.Brightness = 2
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 999999
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
        Lighting.OutdoorAmbient = Color3.fromRGB(255, 255, 255)
        Lighting.ClockTime = 12
    else
        Lighting.Brightness = oldLighting.Brightness
        Lighting.GlobalShadows = oldLighting.GlobalShadows
        Lighting.FogEnd = oldLighting.FogEnd
        Lighting.Ambient = oldLighting.Ambient
        Lighting.OutdoorAmbient = oldLighting.OutdoorAmbient
        Lighting.ClockTime = oldLighting.ClockTime
    end
    fullbrightButton.Text = "Fullbright: " .. (Config.FullbrightEnabled and "ON" or "OFF")
    sendNotification("FULLBRIGHT", Config.FullbrightEnabled and "ON" or "OFF")
end)

autoWallhopButton = CreateButton(ButtonFrame2Left, "Auto Wallhop: " .. (Config.AutoWallhopEnabled and "ON" or "OFF"), function()
    Config.AutoWallhopEnabled = not Config.AutoWallhopEnabled
    autoWallhopButton.Text = "Auto Wallhop: " .. (Config.AutoWallhopEnabled and "ON" or "OFF")
    sendNotification("Auto Wallhop", Config.AutoWallhopEnabled and "Enabled" or "Disabled")
end)

-- Biến cập nhật khi respawn
local character, humanoid, rootPart

local function updateCharacterRefs()
    character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

updateCharacterRefs()
LocalPlayer.CharacterAdded:Connect(updateCharacterRefs)

-- Check tường trước mặt
local function isWallInFront()
    if not rootPart then return false end
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local origin = rootPart.Position + Vector3.new(0, 2, 0) -- raycast từ ngực
    local direction = rootPart.CFrame.LookVector * 2 -- khoảng cách 2 studs
    local result = Workspace:Raycast(origin, direction, raycastParams)

    return result and result.Instance ~= nil
end

-- Thực hiện wallhop
local isPerformingWallHop = false
local function performWallHop()
    if not Config.AutoWallhopEnabled or isPerformingWallHop or not humanoid or not rootPart then return end
    isPerformingWallHop = true

    while Config.AutoWallhopEnabled and isWallInFront() do
        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        rootPart.AssemblyLinearVelocity = Vector3.new(0, 60, 0) -- lực nhảy
        rootPart.CFrame = rootPart.CFrame * CFrame.Angles(0, math.rad(-35), 0)
        task.wait(0.4)
    end

    isPerformingWallHop = false
end

-- Loop
RunService.Heartbeat:Connect(function()
    if Config.AutoWallhopEnabled then
        performWallHop()
    end
end)

-- Hàm tạo Skibidi RedRizz Aura (đổi màu trắng và fade trắng ↔ đen)
local function createSkibidiRedRizz(character)
    local attachment = Instance.new("Attachment")
    attachment.Name = "SkibidiAura"
    attachment.Parent = character and (character:FindFirstChild("LowerTorso") or character:FindFirstChild("HumanoidRootPart"))

    local emitters = {}

    -- HealingWave1
    local HealingWave1 = Instance.new("ParticleEmitter")
    HealingWave1.Name = "Healing Wave 1"
    HealingWave1.Lifetime = NumberRange.new(1.5, 1.5)
    HealingWave1.SpreadAngle = Vector2.new(10, -10)
    HealingWave1.LockedToPart = true
    HealingWave1.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.1702454, 0.7),
        NumberSequenceKeypoint.new(0.2254601, 0.03125),
        NumberSequenceKeypoint.new(0.2852761, 0),
        NumberSequenceKeypoint.new(0.702454, 0),
        NumberSequenceKeypoint.new(0.8374233, 0.9125),
        NumberSequenceKeypoint.new(1, 1)
    })
    HealingWave1.LightEmission = 0.4
    HealingWave1.VelocitySpread = 10
    HealingWave1.Speed = NumberRange.new(3, 6)
    HealingWave1.Brightness = 10
    HealingWave1.Color = ColorSequence.new(Color3.new(1,1,1))
    HealingWave1.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 3.0624998),
        NumberSequenceKeypoint.new(0.6420546, 1.9999999),
        NumberSequenceKeypoint.new(1, 0.7499999)
    })
    HealingWave1.Rate = 20
    HealingWave1.Texture = "rbxassetid://8047533775"
    HealingWave1.RotSpeed = NumberRange.new(200, 400)
    HealingWave1.Rotation = NumberRange.new(-180, 180)
    HealingWave1.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    HealingWave1.Parent = attachment
    table.insert(emitters, HealingWave1)

    -- HealingWave2
    local HealingWave2 = Instance.new("ParticleEmitter")
    HealingWave2.Name = "Healing Wave 2"
    HealingWave2.Lifetime = NumberRange.new(1.5, 1.5)
    HealingWave2.SpreadAngle = Vector2.new(10, -10)
    HealingWave2.LockedToPart = true
    HealingWave2.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 1),
        NumberSequenceKeypoint.new(0.2254601, 0.03125),
        NumberSequenceKeypoint.new(0.6288344, 0.25625),
        NumberSequenceKeypoint.new(0.8374233, 0.9125),
        NumberSequenceKeypoint.new(1, 1)
    })
    HealingWave2.LightEmission = 1
    HealingWave2.VelocitySpread = 10
    HealingWave2.Speed = NumberRange.new(3, 5)
    HealingWave2.Brightness = 10
    HealingWave2.Color = ColorSequence.new(Color3.new(1,1,1))
    HealingWave2.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 3.125),
        NumberSequenceKeypoint.new(0.4165329, 1.3749999),
        NumberSequenceKeypoint.new(1, 0.9375)
    })
    HealingWave2.Rate = 20
    HealingWave2.Texture = "rbxassetid://8047796070"
    HealingWave2.RotSpeed = NumberRange.new(100, 300)
    HealingWave2.Rotation = NumberRange.new(-180, 180)
    HealingWave2.Orientation = Enum.ParticleOrientation.VelocityPerpendicular
    HealingWave2.Parent = attachment
    table.insert(emitters, HealingWave2)

    -- Sparks
    local Sparks = Instance.new("ParticleEmitter")
    Sparks.Name = "Sparks"
    Sparks.Lifetime = NumberRange.new(0.5, 2)
    Sparks.SpreadAngle = Vector2.new(180, -180)
    Sparks.LightEmission = 1
    Sparks.Drag = 3
    Sparks.VelocitySpread = 180
    Sparks.Speed = NumberRange.new(5, 15)
    Sparks.Brightness = 10
    Sparks.Color = ColorSequence.new(Color3.new(1,1,1))
    Sparks.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.14687, 0.4374999),
        NumberSequenceKeypoint.new(1, 0)
    })
    Sparks.Acceleration = Vector3.new(0, 3, 0)
    Sparks.ZOffset = -1
    Sparks.Rate = 40
    Sparks.Texture = "rbxassetid://8611887361"
    Sparks.RotSpeed = NumberRange.new(-30, 30)
    Sparks.Orientation = Enum.ParticleOrientation.VelocityParallel
    Sparks.Parent = attachment
    table.insert(emitters, Sparks)

    -- StarSparks
    local StarSparks = Instance.new("ParticleEmitter")
    StarSparks.Name = "Star Sparks"
    StarSparks.Lifetime = NumberRange.new(1.5, 1.5)
    StarSparks.SpreadAngle = Vector2.new(180, -180)
    StarSparks.LightEmission = 1
    StarSparks.Drag = 3
    StarSparks.VelocitySpread = 180
    StarSparks.Speed = NumberRange.new(5, 10)
    StarSparks.Brightness = 10
    StarSparks.Color = ColorSequence.new(Color3.new(1,1,1))
    StarSparks.Size = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(0.1492777, 0.6874996),
        NumberSequenceKeypoint.new(1, 0)
    })
    StarSparks.Acceleration = Vector3.new(0, 3, 0)
    StarSparks.ZOffset = 2
    StarSparks.Texture = "rbxassetid://8611887703"
    StarSparks.RotSpeed = NumberRange.new(-30, 30)
    StarSparks.Rotation = NumberRange.new(-30, 30)
    StarSparks.Parent = attachment
    table.insert(emitters, StarSparks)

    -- Update màu liên tục (fade trắng ↔ đen)
    task.spawn(function()
        while attachment.Parent do
            local t = math.sin(tick() * 2) * 0.5 + 0.5 -- dao động 0 -> 1
            local col = Color3.new(t,t,t)
            for _, e in ipairs(emitters) do
                e.Color = ColorSequence.new(col)
            end
            task.wait(0.05)
        end
    end)

    return attachment
end

-- Nút bật/tắt Aura Hit Effect
rainbowHitButton = CreateButton(ButtonFrame2Left, "Aura Hit Effect: " .. (Config.RainbowHitEffectEnabled and "ON" or "OFF"), function()
    Config.RainbowHitEffectEnabled = not Config.RainbowHitEffectEnabled
    rainbowHitButton.Text = "Aura Hit Effect: " .. (Config.RainbowHitEffectEnabled and "ON" or "OFF")
    sendNotification("Aura Hit Effect", Config.RainbowHitEffectEnabled and "Enabled" or "Disabled")

    local char = LocalPlayer.Character
    if char then
        local aura = char:FindFirstChild("SkibidiAura")
        if Config.RainbowHitEffectEnabled then
            if not aura then
                createSkibidiRedRizz(char)
            end
        else
            if aura then aura:Destroy() end
        end
    end
end)

-- Khi script load, nếu config bật sẵn thì tạo aura luôn
task.defer(function()
    local char = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
    if Config.RainbowHitEffectEnabled and not char:FindFirstChild("SkibidiAura") then
        createSkibidiRedRizz(char)
    end
end)

-- Giữ aura khi respawn
LocalPlayer.CharacterAdded:Connect(function(char)
    if Config.RainbowHitEffectEnabled then
        task.wait(1) -- chờ load nhân vật đầy đủ
        if not char:FindFirstChild("SkibidiAura") then
            createSkibidiRedRizz(char)
        end
    end
end)

local lastHealth = {}

RunService.Heartbeat:Connect(function()
    if not Config.RainbowHitEffectEnabled then return end

    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            local char = plr and plr.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if hum then
                local current = hum.Health
                local last = lastHealth[name] or current

                if current < last then
                    -- Lấy highlight cũ hoặc tạo mới
                    local highlight = char:FindFirstChild("HitEffectHighlight")
                    if not highlight then
                        highlight = Instance.new("Highlight")
                        highlight.Name = "HitEffectHighlight"
                        highlight.Adornee = char
                        highlight.FillTransparency = 1
                        highlight.OutlineTransparency = 0
                        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                        highlight.Parent = char
                    end

                    -- Hiệu ứng rainbow trong 1 giây
                    task.spawn(function()
                        local start = tick()
                        while tick() - start < 1 and highlight.Parent do
                            highlight.OutlineColor = fadeColor()
                            task.wait(0.05)
                        end
                        -- Sau khi kết thúc, xóa nếu không cần nữa
                        highlight:Destroy()
                    end)
                end

                lastHealth[name] = current
            end
        end
    end
end)

local antiAfkEnabled = false
local antiAfkLoop

antiAfkButton = CreateButton(ButtonFrame2Left, "Anti AFK: OFF", function()
    antiAfkEnabled = not antiAfkEnabled
    antiAfkButton.Text = "Anti AFK: " .. (antiAfkEnabled and "ON" or "OFF")
    sendNotification("ANTI AFK", antiAfkEnabled and "ON" or "OFF")

    if antiAfkEnabled then
        -- Vòng lặp tự nhảy mỗi 60 giây
        antiAfkLoop = task.spawn(function()
            while antiAfkEnabled do
                task.wait(60) -- Đợi 60 giây
                pcall(function()
                    local hum = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end)
            end
        end)
    else
        if antiAfkLoop then
            task.cancel(antiAfkLoop)
            antiAfkLoop = nil
        end
    end
end)

-- Hàm tìm player gần nhất trong danh sách SelectedPlayers
local function getClosestSelected()
    local closest, dist = nil, math.huge
    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for name, selected in pairs(Config.SelectedPlayers or {}) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local d = (myHRP.Position - plr.Character.HumanoidRootPart.Position).Magnitude
                if d < dist then
                    dist = d
                    closest = plr
                end
            end
        end
    end
    return closest
end

-- Biến toàn cục
local animEnabled = false
local animTrack = nil
local bangConnection = nil

-- Hàm dừng animation và teleport
local function stopAnimAndTp()
    if animTrack then
        animTrack:Stop()
        animTrack = nil
    end
    if bangConnection then
        bangConnection:Disconnect()
        bangConnection = nil
    end
    animEnabled = false
end

-- Tạo nút BangPlayer sử dụng CreateButton
bangButton = CreateButton(ButtonFrame2Left, "BangPlayer: OFF", function()
    animEnabled = not animEnabled
    
    if not animEnabled then
        stopAnimAndTp()
        bangButton.Text = "BangPlayer: OFF"
        sendNotification("BangPlayer", "Đã tắt")
    else
        local target = getClosestSelected()
        if not target then
            animEnabled = false
            bangButton.Text = "BangPlayer: OFF"
            return
        end

        local myChar = LocalPlayer.Character
        local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not (myHum and myHRP) then
            animEnabled = false
            bangButton.Text = "BangPlayer: OFF"
            sendNotification("BangPlayer", "Không tìm thấy nhân vật!")
            return
        end

        -- Chọn animation theo rig type
        local anim = Instance.new("Animation")
        anim.AnimationId = myHum.RigType == Enum.HumanoidRigType.R6 and "rbxassetid://148840371" or "rbxassetid://96387457087289"

        -- Phát animation
        animTrack = myHum:LoadAnimation(anim)
        animTrack:Play()
        animTrack:AdjustSpeed(10)

        bangButton.Text = "BangPlayer: ON (" .. target.Name .. ")"
        sendNotification("BangPlayer", "Đang dính theo " .. target.Name)

        -- Teleport liên tục
        bangConnection = RunService.Heartbeat:Connect(function()
            if animEnabled and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                myHRP.CFrame = target.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
            else
                stopAnimAndTp()
                bangButton.Text = "BangPlayer: OFF"
            end
        end)
    end
end)

-- Xử lý khi respawn
LocalPlayer.CharacterAdded:Connect(function()
    if animEnabled then
        task.wait(0.5) -- Đợi nhân vật load
        local target = getClosestSelected()
        if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local myChar = LocalPlayer.Character
            local myHum = myChar and myChar:FindFirstChildOfClass("Humanoid")
            local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
            if myHum and myHRP then
                -- Chọn lại animation theo rig type
                local anim = Instance.new("Animation")
                anim.AnimationId = myHum.RigType == Enum.HumanoidRigType.R6 and "rbxassetid://148840371" or "rbxassetid://5918726674"
                
                -- Xóa quần áo nếu có
                pcall(function()
                    myChar.Pants:Destroy()
                    myChar.Shirt:Destroy()
                end)

                -- Phát lại animation
                animTrack = myHum:LoadAnimation(anim)
                animTrack:Play()
                animTrack:AdjustSpeed(10)

                -- Teleport liên tục
                bangConnection = RunService.Heartbeat:Connect(function()
                    if animEnabled and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
                        myHRP.CFrame = target.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 1)
                    else
                        stopAnimAndTp()
                        bangButton.Text = "BangPlayer: OFF"
                        sendNotification("BangPlayer", "Mục tiêu không hợp lệ, đã tắt!")
                    end
                end)
            end
        else
            stopAnimAndTp()
            bangButton.Text = "BangPlayer: OFF"
            sendNotification("BangPlayer", "Mục tiêu không hợp lệ, đã tắt!")
        end
    end
end)

tpAndStompButton = CreateButton(ButtonFrame2Left, "TP Player", function()
    local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position
    if not myPos then return end

    local closestPlayer, minDist = nil, math.huge

    for name, selected in pairs(Config.SelectedPlayers) do
        if selected then
            local plr = Players:FindFirstChild(name)
            if plr and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local pos = plr.Character.HumanoidRootPart.Position
                local dist = (myPos - pos).Magnitude
                if dist < minDist then
                    closestPlayer = plr
                    minDist = dist
                end
            end
        end
    end

    if closestPlayer then
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if root then
            local pos = closestPlayer.Character.HumanoidRootPart.Position
            root.CFrame = CFrame.new(pos + Vector3.new(0, 0, 0))
        end
    end
end)

local Player = Players.LocalPlayer
local Character
local InvisibleCharacter
local invisRunning = false
local IsInvis = false
local invisFix, invisDied

-- Respawn về trạng thái ban đầu
local function Respawn()
    if IsInvis then
        pcall(function()
            Player.Character = Character
            task.wait()
            Character.Parent = workspace
            Character:FindFirstChildWhichIsA("Humanoid"):Destroy()
            IsInvis = false
            InvisibleCharacter.Parent = nil
            invisRunning = false
        end)
    else
        pcall(function()
            Player.Character = Character
            task.wait()
            Character.Parent = workspace
            Character:FindFirstChildWhichIsA("Humanoid"):Destroy()
            TurnVisible()
        end)
    end
end

-- Tắt invisible
function TurnVisible()
    if not IsInvis then return end
    if invisFix then invisFix:Disconnect() end
    if invisDied then invisDied:Disconnect() end

    local CF_1 = Player.Character.HumanoidRootPart.CFrame
    InvisibleCharacter.Parent = Lighting
    Player.Character = Character
    Character.Parent = workspace
    Character.HumanoidRootPart.CFrame = CF_1
    IsInvis = false
    Player.Character.Animate.Disabled = true
    Player.Character.Animate.Disabled = false

    -- 🔑 Reset Camera khi tắt invis
    task.wait(.1)
    Workspace.CurrentCamera.CameraSubject = Character:FindFirstChildWhichIsA("Humanoid")
    Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    Player.CameraMinZoomDistance = 0.5
    Player.CameraMaxZoomDistance = 400
    Player.CameraMode = "Classic"

    invisRunning = false
end

-- Bật/Tắt invisible
local function ToggleInvisible()
    if invisRunning then return end

    if not IsInvis then
        invisRunning = true
        Player = Players.LocalPlayer
        repeat task.wait(.1) until Player.Character
        Character = Player.Character
        Character.Archivable = true

        InvisibleCharacter = Character:Clone()
        InvisibleCharacter.Parent = Lighting
        InvisibleCharacter.Name = ""

        -- Check rơi xuống void
        local Void = workspace.FallenPartsDestroyHeight
        invisFix = RunService.Stepped:Connect(function()
            pcall(function()
                local Y = Player.Character.HumanoidRootPart.Position.Y
                if tostring(Void):find"-" then
                    if Y <= Void then Respawn() end
                else
                    if Y >= Void then Respawn() end
                end
            end)
        end)

        -- Làm mờ clone
        for _,v in pairs(InvisibleCharacter:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Transparency = (v.Name == "HumanoidRootPart") and 1 or 0.5
            end
        end

        -- Handle chết
        invisDied = InvisibleCharacter:FindFirstChildOfClass("Humanoid").Died:Connect(function()
            Respawn()
            invisDied:Disconnect()
        end)

        -- Swap sang invisible
        IsInvis = true
        local CF_1 = Character.HumanoidRootPart.CFrame
        Character:MoveTo(Vector3.new(0,math.pi*1000000,0))
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
        task.wait(.1)
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        Character.Parent = Lighting
        InvisibleCharacter.Parent = Workspace
        InvisibleCharacter.HumanoidRootPart.CFrame = CF_1
        Player.Character = InvisibleCharacter

        task.wait(.1)
        Workspace.CurrentCamera.CameraSubject = Player.Character:FindFirstChildWhichIsA("Humanoid")
        Workspace.CurrentCamera.CameraType = "Custom"
        Player.CameraMinZoomDistance = 0.5
        Player.CameraMaxZoomDistance = 400
        Player.CameraMode = "Classic"
        Player.Character.Animate.Disabled = true
        Player.Character.Animate.Disabled = false

        invisRunning = false -- cho phép toggle lần nữa
    else
        TurnVisible()
        IsInvis = false
        invisRunning = false
    end
end

-- Nút Invisible ở Page2Left
local invisibleButton = CreateButton(ButtonFrame2Left, "Invisible: " .. (IsInvis and "ON" or "OFF"), function()
    if not IsInvis then
        ToggleInvisible() -- Bật invis
    else
        TurnVisible()     -- Tắt invis
        IsInvis = false
        invisRunning = false
    end
    
    -- Cập nhật nút và notify
    invisibleButton.Text = "Invisible: " .. (IsInvis and "ON" or "OFF")
    sendNotification("Invisible", IsInvis and "ON" or "OFF")
end)

noclipButton = CreateButton(ButtonFrame2Left, "Noclip: OFF", function()
    Config.NoclipEnabled = not Config.NoclipEnabled
    
    if Config.NoclipEnabled then
        if noclipConnection then noclipConnection:Disconnect() end
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
    end

   sendNotification("NOCLIP", Config.NoclipEnabled and "ON" or "OFF")
    noclipButton.Text = "Noclip: " .. (Config.NoclipEnabled and "ON" or "OFF")
end)

-- Đảm bảo noclip vẫn bật khi respawn
LocalPlayer.CharacterAdded:Connect(function()
    if Config.NoclipEnabled then
        task.wait(0.5) -- đợi nhân vật load
        noclipConnection = RunService.Stepped:Connect(function()
            local char = LocalPlayer.Character
            if char and char:FindFirstChildOfClass("Humanoid") then
                for _, part in ipairs(char:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = false
                    end
                end
            end
        end)
    end
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

-- ID animation
local animations = {
    happier = "http://www.roblox.com/asset/?id=15609995579",
    happy = "http://www.roblox.com/asset/?id=14352343065",
    siuu = "rbxassetid://120331939816115",
    sturdy = "rbxassetid://128968764985212",
    cutesit = "rbxassetid://97459465855185",
    matching1 = "rbxassetid://102139040629559",
    matching2 = "rbxassetid://110235213168404",
    hug1 = "rbxassetid://105797917228398",
    hug2 = "rbxassetid://118264035209903",
    sit1 = "rbxassetid://94749062881621",
    sit2 = "rbxassetid://110800242342916",
}

local currentTrack = nil

-- Hàm dừng animation
local function stopAnimation()
    if currentTrack then
        currentTrack:Stop()
        currentTrack = nil
    end
end

-- Hàm phát animation
local function playAnimation(animId)
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChildOfClass("Humanoid") then return end
    local hum = char:FindFirstChildOfClass("Humanoid")

    -- Đang di chuyển thì không phát
    if hum.MoveDirection.Magnitude > 0 then return end

    -- Ngừng animation cũ nếu có
    stopAnimation()

    -- Tạo animator nếu chưa có
    local animator = hum:FindFirstChildOfClass("Animator") or Instance.new("Animator", hum)

    local anim = Instance.new("Animation")
    anim.AnimationId = animId
    local track = animator:LoadAnimation(anim)
    track:Play()
    currentTrack = track
end

-- Khi respawn vẫn dùng được
LocalPlayer.CharacterAdded:Connect(function()
    currentTrack = nil
end)

-- Liên tục kiểm tra nếu bắt đầu di chuyển thì dừng animation
RunService.RenderStepped:Connect(function()
    local char = LocalPlayer.Character
    if char and currentTrack then
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum and hum.MoveDirection.Magnitude > 0 then
            stopAnimation()
        end
    end
end)

-- Tạo 2 nút
CreateButton(ButtonFrame2Right, "Happier Jump", function()
    playAnimation(animations.happier)
end)

CreateButton(ButtonFrame2Right, "Happy", function()
    playAnimation(animations.happy)
end)

CreateButton(ButtonFrame2Right, "siuu", function()
    playAnimation(animations.siuu)
end)

CreateButton(ButtonFrame2Right, "sturdy", function()
    playAnimation(animations.sturdy)
end)

CreateButton(ButtonFrame2Right, "cutesit", function()
    playAnimation(animations.cutesit)
end)

CreateButton(ButtonFrame2Right, "matching1", function()
    playAnimation(animations.matching1)
end)

CreateButton(ButtonFrame2Right, "matching2", function()
    playAnimation(animations.matching2)
end)

CreateButton(ButtonFrame2Right, "hug1", function()
    playAnimation(animations.hug1)
end)

CreateButton(ButtonFrame2Right, "hug2", function()
    playAnimation(animations.hug2)
end)

CreateButton(ButtonFrame2Right, "sit1", function()
    playAnimation(animations.sit1)
end)

CreateButton(ButtonFrame2Right, "sit2", function()
    playAnimation(animations.sit2)
end)

local function giveClickTpTool()
    if clickTpTool then clickTpTool:Destroy() end
    clickTpTool = Instance.new("Tool")
    clickTpTool.RequiresHandle = false
    clickTpTool.Name = "ClickTP"
    clickTpTool.Parent = LocalPlayer.Backpack

    clickTpTool.Activated:Connect(function()
        local mouse = LocalPlayer:GetMouse()
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            if mouse and mouse.Hit then
                local targetPos = mouse.Hit.p + Vector3.new(0, 3, 0) -- cách mặt đất 3 stud
                LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos)
            end
        end
    end)
end

-- Nút bật/tắt
clickTpButton = CreateButton(ButtonFrame2Right, "Click TP: OFF", function()
    Config.clickTpEnabled = not Config.clickTpEnabled
    sendNotification("GIVECLICKTOOL", Config.clickTpEnabled and "ON" or "OFF")
    clickTpButton.Text = "Click TP: " .. (Config.clickTpEnabled and "ON" or "OFF")
    if Config.clickTpEnabled then
        giveClickTpTool()
        sendNotification("Click TP", "Đã cấp tool Click TP vào Backpack!")
    else
        if clickTpTool then
            clickTpTool:Destroy()
            clickTpTool = nil
        end
    end
end)

-- Khi respawn thì gắn lại tool nếu đang bật
LocalPlayer.CharacterAdded:Connect(function()
    if Config.clickTpEnabled then
        task.wait(0.5) -- đợi nhân vật load
        giveClickTpTool()
    end
end)

saveWaypointButton = CreateButton(ButtonFrame2Right, "Save Waypoint", function()
    if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        savedWaypoint = LocalPlayer.Character.HumanoidRootPart.CFrame
        sendNotification("Waypoint", "Đã lưu vị trí hiện tại!")
    else
        sendNotification("Waypoint", "Không thể lưu vị trí!")
    end
end)

tpWaypointButton = CreateButton(ButtonFrame2Right, "TP to Waypoint", function()
    if savedWaypoint and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = savedWaypoint
        sendNotification("Waypoint", "Đã teleport tới vị trí đã lưu!")
    else
        sendNotification("Waypoint", "Chưa có vị trí được lưu!")
    end
end)

spinbotButton = CreateButton(ButtonFrame2Right, "Spinbot: " .. (Config.SpinbotEnabled and "ON" or "OFF"), function()
    Config.SpinbotEnabled = not Config.SpinbotEnabled
    spinbotButton.Text = "Spinbot: " .. (Config.SpinbotEnabled and "ON" or "OFF")
    sendNotification("Spinbot", Config.SpinbotEnabled and "Enabled" or "Disabled")
end)

-- Ô nhập Speed
local spinbotSpeedBox = Instance.new("TextBox")
spinbotSpeedBox.Size = UDim2.new(1, 0, 0, 20)
spinbotSpeedBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
spinbotSpeedBox.TextColor3 = Color3.new(1, 1, 1)
spinbotSpeedBox.Text = tostring(Config.SpinbotSpeed)
spinbotSpeedBox.PlaceholderText = "Speed"
spinbotSpeedBox.ClearTextOnFocus = false
spinbotSpeedBox.Font = Enum.Font.GothamBold
spinbotSpeedBox.TextSize = 12
spinbotSpeedBox.Parent = ButtonFrame2Right
Instance.new("UICorner", spinbotSpeedBox).CornerRadius = UDim.new(0, 4)

spinbotSpeedBox.FocusLost:Connect(function()
    local num = tonumber(spinbotSpeedBox.Text)
    if num then
        Config.SpinbotSpeed = num
    else
        spinbotSpeedBox.Text = tostring(Config.SpinbotSpeed)
    end
end)

-- Logic Spinbot
RunService.RenderStepped:Connect(function(delta)
    if Config.SpinbotEnabled then
        local char = LocalPlayer.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChild("Humanoid")
        if hrp and hum then
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, math.rad(Config.SpinbotSpeed) * delta, 0)
            hum.AutoRotate = false
        end
    else
        local hum = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if hum then hum.AutoRotate = true end
    end
end)

-- Anti Fling Button (Page 2, Right Side)
local antiFlingEnabled = false

local antiFlingButton = CreateButton(ButtonFrame2Right, "Anti Fling: " .. (antiFlingEnabled and "ON" or "OFF"), function()
    antiFlingEnabled = not antiFlingEnabled
    antiFlingButton.Text = "Anti Fling: " .. (antiFlingEnabled and "ON" or "OFF")
    sendNotification("Anti Fling", antiFlingEnabled and "Enabled" or "Disabled")
end)

-- Logic an toàn
local localPlayer = Players.LocalPlayer
local hrp = nil
local lastPos

local function protectHRP()
    if localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
        hrp = localPlayer.Character.HumanoidRootPart
    end
end

localPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    protectHRP()
end)
protectHRP()

RunService.Heartbeat:Connect(function()
    if antiFlingEnabled and hrp then
        -- chặn velocity quá cao
        if hrp.AssemblyLinearVelocity.Magnitude > 100 then
            hrp.AssemblyLinearVelocity = Vector3.zero
        end
        if hrp.AssemblyAngularVelocity.Magnitude > 100 then
            hrp.AssemblyAngularVelocity = Vector3.zero
        end

        -- nếu bị đẩy quá xa trong 1 tick -> đưa về vị trí cũ
        if lastPos and (hrp.Position - lastPos).Magnitude > 40 then
            hrp.CFrame = CFrame.new(lastPos)
            hrp.AssemblyLinearVelocity = Vector3.zero
            hrp.AssemblyAngularVelocity = Vector3.zero
        end
        lastPos = hrp.Position
    end
end)

local hiddenFling = false
local flingPower = 55000
local movel = 0.1

local function flingLoop()
    local lp = Players.LocalPlayer
    local hrp, c, vel

    task.spawn(function()
        while true do
            RunService.Heartbeat:Wait()
            if hiddenFling then
                while hiddenFling and not (c and c.Parent and hrp and hrp.Parent) do
                    RunService.Heartbeat:Wait()
                    c = lp.Character
                    hrp = c and c:FindFirstChild("HumanoidRootPart")
                end

                if hiddenFling and hrp then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                    RunService.RenderStepped:Wait()
                    if hrp.Parent then
                        hrp.Velocity = vel
                    end
                    RunService.Stepped:Wait()
                    if hrp.Parent then
                        hrp.Velocity = vel + Vector3.new(0, movel, 0)
                        movel = movel * -1
                    end
                end
            end
        end
    end)
end

flingLoop()

flintTouchButton = CreateButton(ButtonFrame2Right, "FlintTouch: OFF", function()
    hiddenFling = not hiddenFling
    sendNotification("FLINGTOUCH", hiddenFling and "ON" or "OFF")
    flintTouchButton.Text = "FlintTouch: " .. (hiddenFling and "ON" or "OFF")
end)

rejoinButton = CreateButton(ButtonFrame2Right, "Rejoin", function()
    TeleportService:Teleport(game.PlaceId, LocalPlayer)
end)

serverHopButton = CreateButton(ButtonFrame2Right, "Server Hop", function()
    local api = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Asc&limit=100"
    local response = HttpService:JSONDecode(game:HttpGet(api))
    local servers = response.data
    if #servers > 0 then
        local randomServer = servers[math.random(1, #servers)]
        TeleportService:TeleportToPlaceInstance(game.PlaceId, randomServer.id, LocalPlayer)
    else
        sendNotification("Server Hop", "No servers found!")
    end
end)

-- ESP
local espGui = Instance.new("ScreenGui")
espGui.Name = "SafeESP"
espGui.ResetOnSpawn = false
espGui.IgnoreGuiInset = true
espGui.Parent = PlayerGui

local ESPs = {}

local function IsValidTarget(player)
    if not player 
        or not player.Character 
        or not player.Character:FindFirstChild("Humanoid") 
        or not player.Character:FindFirstChild("HumanoidRootPart") 
        or player.Character.Humanoid.Health <= 0 then
        return false
    end

    local bodyEffects = player.Character:FindFirstChild("BodyEffects")
    local koValue = bodyEffects and bodyEffects:FindFirstChild("K.O")
    if koValue and koValue.Value then
        return false -- Bỏ qua người chơi nếu họ bị K.O
    end

    -- Kiểm tra trạng thái Grab
    if player.Character:FindFirstChild("GRABBING_CONSTRAINT") then
        return false -- Bỏ qua nếu đang bị grab
    end

    return true
end

local function CreateESP(player)
    if ESPs[player] or player == LocalPlayer then return end
    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.TextColor3 = Color3.fromRGB(255, 179, 186)
    label.TextSize = 16
    label.Font = Enum.Font.GothamBold
    label.Text = player.DisplayName
    label.TextStrokeTransparency = 0.5
    label.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    label.Size = UDim2.new(0, 200, 0, 20)
    label.AnchorPoint = Vector2.new(0.5, 0.5)
    label.Position = UDim2.new(0.5, 0, 0.5, 0)
    label.Visible = false
    label.Parent = espGui

    local highlight = Instance.new("Highlight")
    highlight.Enabled = false
    highlight.FillTransparency = 0.6
    highlight.OutlineTransparency = 0.2
    highlight.FillColor = Color3.fromRGB(55, 55, 55)
    highlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    highlight.Adornee = player.Character
    highlight.Parent = espGui

    ESPs[player] = { label = label, highlight = highlight }
end

local function RemoveESP(player)
    if ESPs[player] then
        pcall(function()
            ESPs[player].label:Destroy()
            ESPs[player].highlight:Destroy()
        end)
        ESPs[player] = nil
    end
end

local function UpdateESP()
    if not Config.ESPEnabled then
        for _, v in pairs(ESPs) do
            v.label.Visible = false
            v.highlight.Enabled = false
        end
        return
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and IsValidTarget(player) then
            local character = player.Character
            local head = character:FindFirstChild("Head")
            if head then
                CreateESP(player)
                local headPos = head.Position
                local screenPos, onScreen = Camera:WorldToViewportPoint(headPos)
                local esp = ESPs[player]
                if esp then
                    local isSelected = Config.SelectedPlayers[player.Name]
                    esp.label.TextColor3 = isSelected and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 255, 255)
                    esp.highlight.FillColor = isSelected and Color3.fromRGB(255, 100, 100) or Color3.fromRGB(255, 255, 255)
                    if onScreen then
                        esp.label.Visible = true
                        esp.label.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y - 20)
                        esp.highlight.Enabled = true
                    else
                        esp.label.Visible = false
                        esp.highlight.Enabled = false
                    end
                end
            else
                RemoveESP(player)
            end
        else
            RemoveESP(player)
        end
    end
end

local function UpdateSpeed()
    if Config.SpeedEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local humanoid = LocalPlayer.Character.Humanoid
        local moveDirection = humanoid.MoveDirection
        local speedAmount = Config.SpeedAmount / 8
        root.CFrame = root.CFrame + moveDirection * speedAmount
    end
end

local function UpdateFly(deltaTime)
    if Config.FlyEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local root = LocalPlayer.Character.HumanoidRootPart
        local moveDirection = LocalPlayer.Character.Humanoid.MoveDirection
        local flySpeed = Config.FlySpeed
        local vertical = UserInputService:IsKeyDown(Enum.KeyCode.Space) and flySpeed / 8 or UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) and -flySpeed / 8 or 0
        root.CFrame = root.CFrame + moveDirection * deltaTime * flySpeed * 10
        root.CFrame = root.CFrame + Vector3.new(0, vertical, 0)
        root.Velocity = root.Velocity * Vector3.new(1, 0, 1) + Vector3.new(0, 1.9, 0)
    end
end

local function UpdatePlayerList()
    for _, cd in pairs(PlayerListFrame:GetChildren()) do
        if cd:IsA("TextButton") then cd:Destroy() end
    end
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            local button = Instance.new("TextButton")
            button.Size = UDim2.new(1, -4, 0, 20)
            button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
            button.BackgroundTransparency = 0.2
            button.TextColor3 = Color3.fromRGB(0, 0, 0)
            button.TextSize = 14
            button.Font = Enum.Font.Gotham
            button.AutoButtonColor = false
            button.Parent = PlayerListFrame
            local function UpdateButtonText()
                local isSelected = Config.SelectedPlayers[player.Name]
                button.Text = (isSelected and "✓ " or "") .. player.DisplayName
            end
            button.MouseButton1Click:Connect(function()
                Config.SelectedPlayers[player.Name] = not Config.SelectedPlayers[player.Name]
                UpdateButtonText()
            end)
            attachButtonEffects(button, 3)
            UpdateButtonText()
        end
    end
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Y then
        autoSelect = not autoSelect
        if autoSelect then
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    Config.SelectedPlayers[player.Name] = true
                end
            end
        else
            Config.SelectedPlayers = {}
        end
        UpdatePlayerList()
    end
end)

local UIS = game:GetService("UserInputService")

UIS.InputBegan:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton2 and not gameProcessed then
        getgenv().Aimbot.Status = true
    end
end)

UIS.InputEnded:Connect(function(input, gameProcessed)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        getgenv().Aimbot.Status = false
    end
end)

local hitParts = {
    "Head", "HumanoidRootPart", "UpperTorso", "LowerTorso", "LeftUpperArm", "LeftLowerArm", "LeftHand",
    "RightUpperArm", "RightLowerArm", "RightHand", "LeftUpperLeg", "LeftLowerLeg", "LeftFoot",
    "RightUpperLeg", "RightLowerLeg", "RightFoot", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg"
}

local function validPart(p)
    if not p or not p.Parent or not p.Parent:FindFirstChild("Humanoid") then return false end
    local player = Players:GetPlayerFromCharacter(p.Parent)
    if not player or not Config.SelectedPlayers[player.Name] then return false end
    for _, n in ipairs(hitParts) do
        if p.Name:lower() == n:lower() then return true end
    end
    return false
end

local function distToCursor(part)
    local v, vis = Camera:WorldToViewportPoint(part.Position)
    if not vis then return math.huge end
    local m = UserInputService.TouchEnabled and Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) or UserInputService:GetMouseLocation()
    return (Vector2.new(v.X, v.Y) - Vector2.new(m.X, m.Y)).Magnitude
end

local function click()
    if UserInputService.TouchEnabled then
        local touchPos = UserInputService:GetMouseLocation()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.Begin, touchPos)
        task.wait()
        VirtualInputManager:SendTouchEvent(0, Enum.UserInputState.End, touchPos)
    else
        if mouse1press then
            mouse1press()
            mouse1release()
        elseif mouse1click then
            mouse1click()
        end
    end
end

local function GetBestTargetPart()
    local bestPart, bestDist = nil, fovRadius
    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and Config.SelectedPlayers[plr.Name] and isAlive(plr) and plr.Character then
            for _, partName in ipairs(hitParts) do
                local part = plr.Character:FindFirstChild(partName)
                if part and part:IsA("BasePart") then
                    local dist = distToCursor(part)
                    if dist < bestDist then
                        bestPart = part
                        bestDist = dist
                    end
                end
            end
        end
    end
    return bestPart
end

getgenv().Aimbot = {
    Status = true,
    Hitpart = "Head",
}

local function IsObstructed(origin, targetPos)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
    local result = Workspace:Raycast(origin, (targetPos - origin), raycastParams)
    if result and result.Instance and not result.Instance:IsDescendantOf(Player and Player.Character) then
        return true
    end
    return false
end

local function GetClosestValidPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    local myChar = LocalPlayer.Character
    local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and Config.SelectedPlayers[plr.Name] and isAlive(plr) and plr.Character then
            local targetPart = plr.Character:FindFirstChild(getgenv().Aimbot.Hitpart)
            local targetHRP = plr.Character:FindFirstChild("HumanoidRootPart")
            if targetPart and targetHRP then
                -- Tính khoảng cách 3D trong game
                local dist = (myHRP.Position - targetHRP.Position).Magnitude
                if dist < shortestDistance then
                    closestPlayer = plr
                    shortestDistance = dist
                end
            end
        end
    end

    return closestPlayer
end

RunService.RenderStepped:Connect(function(deltaTime)
    UpdateESP()
    UpdateSpeed()
    UpdateFly(deltaTime)

    if Config.AimbotEnabled and getgenv().Aimbot.Status then
        Player = GetClosestValidPlayer()
        if Player and Player.Character and Player.Character:FindFirstChild(getgenv().Aimbot.Hitpart) then
            local part = Player.Character[getgenv().Aimbot.Hitpart]
            local ping = Config.AutoPredictionEnabled and GetPing() or Config.CustomPing
            local predictedPos = CalculateVIPPrediction(part, ping)
            if predictedPos and not IsObstructed(Camera.CFrame.Position, predictedPos) then
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, predictedPos)
            end
        end
    end

    -- TRIGGERBOT
    if tbEnabled then
        local part = GetBestTargetPart()
        if part then
            task.spawn(function()
                local cap = part
                task.wait(0)
                if tbEnabled and distToCursor(cap) <= fovRadius then
                    local origin = Camera.CFrame.Position
                    local direction = (cap.Position - origin)
                    local rayParams = RaycastParams.new()
                    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
                    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}

                    local result = Workspace:Raycast(origin, direction, rayParams)

                    -- Chỉ bắn nếu raycast trúng chính xác target (không bị che)
                    if not result or result.Instance:IsDescendantOf(cap.Parent) then
                        if UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
                            -- Mobile
                            local char = LocalPlayer.Character
                            local fired = false
                            if char then
                                for _, tool in ipairs(char:GetChildren()) do
                                    if tool:IsA("Tool") then
                                        pcall(function() tool:Activate() end)
                                        fired = true
                                        break
                                    end
                                end
                            end
                            if not fired then
                                click() -- fallback tap
                            end
                        else
                            -- PC
                            click()
                        end
                    end
                end
            end)
        end
    end
end)

local Connections = {}
local function Connect(event, callback)
    local connection = event:Connect(callback)
    table.insert(Connections, connection)
    return connection
end

Connect(Players.PlayerRemoving, function(player)
    RemoveESP(player)
    UpdatePlayerList()
end)

Connect(Players.PlayerAdded, function(player)
    task.wait(math.random(2, 3))
    RemoveESP(player)
    if Config.SelectedPlayers[player.Name] then
        Config.SelectedPlayers[player.Name] = true 
    end
    UpdatePlayerList()
end)

task.spawn(function()
    while true do
        UpdatePlayerList()
        task.wait(math.random(12, 15))
    end
end)

-- === Nút Select Target ===
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local FOV_RADIUS = 200

-- Hàm lấy player gần chuột nhất trong FOV
local function GetClosestValidPlayer()
    local closest, shortestDist = nil, math.huge
    local mousePos = UserInputService:GetMouseLocation()

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
            local hrp = plr.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if onScreen then
                local distFromMouse = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if distFromMouse <= FOV_RADIUS and distFromMouse < shortestDist then
                    shortestDist = distFromMouse
                    closest = plr
                end
            end
        end
    end
    return closest
end

-- Tạo nút nổi ngoài màn hình
local selectGui = Instance.new("ScreenGui")
selectGui.Name = "SelectTargetGui"
selectGui.ResetOnSpawn = false -- chết không mất
selectGui.Parent = CoreGui

local selectBtn = Instance.new("TextButton")
selectBtn.Size = UDim2.new(0, 110, 0, 35)
selectBtn.Position = UDim2.new(0, 300, 0, 200)
selectBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
selectBtn.Text = "Set Target"
selectBtn.Font = Enum.Font.GothamBold
selectBtn.TextSize = 14
selectBtn.TextColor3 = Color3.new(230, 230, 230)
selectBtn.Parent = selectGui
Instance.new("UICorner", selectBtn).CornerRadius = UDim.new(0, 8)

-- Cho phép kéo nút
local dragging, dragStart, startPos
selectBtn.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = selectBtn.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        selectBtn.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)

-- Xử lý khi click
selectBtn.MouseButton1Click:Connect(function()
    local target = GetClosestValidPlayer()
    if target then
        local displayName = target.DisplayName
        local username = target.Name

        if Config.SelectedPlayers[username] then
            Config.SelectedPlayers[username] = nil
            game.StarterGui:SetCore("SendNotification", {
                Title = "Set Target",
                Text = "Bỏ chọn: " .. displayName,
                Duration = 2
            })
        else
            Config.SelectedPlayers[username] = true
            game.StarterGui:SetCore("SendNotification", {
                Title = "Select Target",
                Text = "Đã chọn: " .. displayName,
                Duration = 2
            })
        end

        if UpdateSelectedPlayersUI then
            UpdateSelectedPlayersUI() -- cập nhật danh sách GUI ngay
        end
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Set Target",
            Text = "Không tìm thấy mục tiêu trong FOV",
            Duration = 2
        })
    end
end)

-- Bắt sự kiện bấm chuột giữa để chọn target
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton3 then -- Chuột giữa
        local target = GetClosestValidPlayer()
        if target then
            local displayName = target.DisplayName
            local username = target.Name

            if Config.SelectedPlayers[username] then
                Config.SelectedPlayers[username] = nil
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Set Target",
                    Text = "Bỏ chọn: " .. displayName,
                    Duration = 2
                })
            else
                Config.SelectedPlayers[username] = true
                game.StarterGui:SetCore("SendNotification", {
                    Title = "Select Target",
                    Text = "Đã chọn: " .. displayName,
                    Duration = 2
                })
            end

            if UpdateSelectedPlayersUI then
                UpdateSelectedPlayersUI()
            end
        else
            game.StarterGui:SetCore("SendNotification", {
                Title = "Set Target",
                Text = "Không tìm thấy mục tiêu trong FOV",
                Duration = 2
            })
        end
    end
end)
